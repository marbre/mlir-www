<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::linalg Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">13.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1linalg.html">linalg</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::linalg Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir_1_1linalg_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1AffineMapAndOperands.html">AffineMapAndOperands</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct to return the results of <code>substituteMin</code>.  <a href="structmlir_1_1linalg_1_1AffineMapAndOperands.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1AffineMinRangeCanonicalizationPattern.html">AffineMinRangeCanonicalizationPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize AffineMinOp operations in the context of ops with a known range by:  <a href="structmlir_1_1linalg_1_1AffineMinRangeCanonicalizationPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1AffineMinSCFCanonicalizationPattern.html">AffineMinSCFCanonicalizationPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of <code><a class="el" href="structmlir_1_1linalg_1_1AffineMinRangeCanonicalizationPattern.html" title="Canonicalize AffineMinOp operations in the context of ops with a known range by: ">AffineMinRangeCanonicalizationPattern</a></code> pattern using <code>getSCFMinMaxExpr</code> to know the min and max expression of induction variables from scf loops.  <a href="structmlir_1_1linalg_1_1AffineMinSCFCanonicalizationPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1Aliases.html">Aliases</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A very primitive alias analysis which just records for each view, either:  <a href="classmlir_1_1linalg_1_1Aliases.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1CodegenStrategy.html">CodegenStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Codegen strategy controls how a Linalg op is progressively lowered.  <a href="structmlir_1_1linalg_1_1CodegenStrategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1ConvOpVectorization.html">ConvOpVectorization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts Convolution op into vector contraction.  <a href="classmlir_1_1linalg_1_1ConvOpVectorization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1CopyOpToLibraryCallRewrite.html">CopyOpToLibraryCallRewrite</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite pattern specialization for CopyOp, kicks in when both input and output permutations are left unspecified or are the identity.  <a href="classmlir_1_1linalg_1_1CopyOpToLibraryCallRewrite.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1CopyTransposeRewrite.html">CopyTransposeRewrite</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite CopyOp with permutations into a sequence of TransposeOp and permutation-free CopyOp.  <a href="classmlir_1_1linalg_1_1CopyTransposeRewrite.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ExtractSliceOfPadTensorSwapPattern.html">ExtractSliceOfPadTensorSwapPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite extract_slice(pad_tensor(x)) into pad_tensor(extract_slice(x)).  <a href="structmlir_1_1linalg_1_1ExtractSliceOfPadTensorSwapPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containing the Linalg producer before and after fusion.  <a href="structmlir_1_1linalg_1_1FusionInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1GeneralizePadTensorOpPattern.html">GeneralizePadTensorOpPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite a PadTensorOp into a sequence of InitTensorOp, FillOp and InsertSliceOp.  <a href="structmlir_1_1linalg_1_1GeneralizePadTensorOpPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1GenerateLoopNest.html">GenerateLoopNest</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class used to generate nested loops with ranges described by <code>loopRanges</code> and loop type described by the <code>iteratorTypes</code>.  <a href="structmlir_1_1linalg_1_1GenerateLoopNest.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1GenericOpInterchangePattern.html">GenericOpInterchangePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg generic interchage pattern.  <a href="structmlir_1_1linalg_1_1GenericOpInterchangePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LateCodegenStrategyOptions.html">LateCodegenStrategyOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to control the application of late transformations.  <a href="structmlir_1_1linalg_1_1LateCodegenStrategyOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgBasePromotionPattern.html">LinalgBasePromotionPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg promotion patterns.  <a href="structmlir_1_1linalg_1_1LinalgBasePromotionPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgBaseTileAndFusePattern.html">LinalgBaseTileAndFusePattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgBaseTilingPattern.html">LinalgBaseTilingPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base pattern that applied the tiling transformation specified by <code>options</code>.  <a href="structmlir_1_1linalg_1_1LinalgBaseTilingPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgBaseVectorizationPattern.html">LinalgBaseVectorizationPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgCopyVTRForwardingPattern.html">LinalgCopyVTRForwardingPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match and rewrite for the pattern: ``` alloc = ...  <a href="structmlir_1_1linalg_1_1LinalgCopyVTRForwardingPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgCopyVTWForwardingPattern.html">LinalgCopyVTWForwardingPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match and rewrite for the pattern: ``` alloc = ...  <a href="structmlir_1_1linalg_1_1LinalgCopyVTWForwardingPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for holding a dependence graph that operates on LinalgOp and views as SSA values.  <a href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgElementwiseFusionOptions.html">LinalgElementwiseFusionOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options that control fusion of elementwise operations.  <a href="structmlir_1_1linalg_1_1LinalgElementwiseFusionOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgFusionOptions.html">LinalgFusionOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgLoopDistributionOptions.html">LinalgLoopDistributionOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options that allow distribution of loops generated in Linalg transforms to processors while generating the loops.  <a href="structmlir_1_1linalg_1_1LinalgLoopDistributionOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgLoweringPattern.html">LinalgLoweringPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1LinalgOpToLibraryCallRewrite.html">LinalgOpToLibraryCallRewrite</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionPattern.html">LinalgPromotionPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgTileAndFusePattern.html">LinalgTileAndFusePattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgTilingPattern.html">LinalgTilingPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">LinalgTransformationFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to control application of linalg transformation patterns.  <a href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgTransforms.html">LinalgTransforms</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgVectorizationOptions.html">LinalgVectorizationOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg vectorization patterns.  <a href="structmlir_1_1linalg_1_1LinalgVectorizationOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgVectorizationPattern.html">LinalgVectorizationPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1OpOperandVector.html">OpOperandVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation. ">OpOperand</a> vector that implicitly converts to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> vector.  <a href="structmlir_1_1linalg_1_1OpOperandVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1PadTensorOpTransformationPattern.html">PadTensorOpTransformationPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PadTensorOp is not canonicalized away yet, so we provide a transformation to <code>linalg.generic</code>.  <a href="structmlir_1_1linalg_1_1PadTensorOpTransformationPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ProcInfo.html">ProcInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to get processor ID, and number of processors used for distribution for all parallel loops generated.  <a href="structmlir_1_1linalg_1_1ProcInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1Promote.html">Promote</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotion transformation enqueues a particular stage-1 pattern for <code><a class="el" href="structmlir_1_1linalg_1_1Promote.html" title="Promotion transformation enqueues a particular stage-1 pattern for Promote&lt;LinalgOpType&gt;with the appr...">Promote</a>&lt;LinalgOpType&gt;</code>with the appropriate <code>options</code>.  <a href="structmlir_1_1linalg_1_1Promote.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1PromotionInfo.html">PromotionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new buffer using the <code>allocationFn</code> provided.  <a href="structmlir_1_1linalg_1_1PromotionInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1RangeType.html">RangeType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmlir_1_1linalg_1_1RangeType.html" title="A RangeType represents a minimal range abstraction (min, max, step). ">RangeType</a> represents a minimal range abstraction (min, max, step).  <a href="classmlir_1_1linalg_1_1RangeType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1RegionMatcher.html">RegionMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containing common matchers over linalg op's region.  <a href="structmlir_1_1linalg_1_1RegionMatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1Tile.html">Tile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotion transformation enqueues a particular stage-1 pattern for <code><a class="el" href="structmlir_1_1linalg_1_1Tile.html" title="Promotion transformation enqueues a particular stage-1 pattern for Tile&lt;LinalgOpType&gt;with the appropr...">Tile</a>&lt;LinalgOpType&gt;</code>with the appropriate <code>options</code>.  <a href="structmlir_1_1linalg_1_1Tile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1TiledAndFusedLinalgOps.html">TiledAndFusedLinalgOps</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse a sequence of linalg operations (<code>ops</code>) using tile-and-fuse.  <a href="structmlir_1_1linalg_1_1TiledAndFusedLinalgOps.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">TiledLinalgOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs standalone tiling of a single LinalgOp by <code>tileSizes</code>.  <a href="structmlir_1_1linalg_1_1TiledLinalgOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1Transformation.html">Transformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract <a class="el" href="structmlir_1_1linalg_1_1Transformation.html" title="Abstract Transformation class applied in a sequence that also handles state through markers...">Transformation</a> class applied in a sequence that also handles state through markers.  <a href="structmlir_1_1linalg_1_1Transformation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1Vectorize.html">Vectorize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorization transformation enqueues a particular stage-1 pattern for <code><a class="el" href="structmlir_1_1linalg_1_1LinalgVectorizationPattern.html">LinalgVectorizationPattern</a>&lt;LinalgOpType&gt;</code> as well as copy to vector transfer rewrite forwarding patterns.  <a href="structmlir_1_1linalg_1_1Vectorize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a949f3c7a426d9e0cfec01467631f8037"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a949f3c7a426d9e0cfec01467631f8037">LoopRangeBuilder</a> = std::function&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a>, 4 &gt;(<a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html">ImplicitLocOpBuilder</a>)&gt;</td></tr>
<tr class="separator:a949f3c7a426d9e0cfec01467631f8037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9ca79033211e3e53e0eb25a8e9551b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, 4 &gt;</td></tr>
<tr class="separator:a4a9ca79033211e3e53e0eb25a8e9551b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0c7d5683991009cfddd7748b7f8d4d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7f0c7d5683991009cfddd7748b7f8d4d">ControlElementwiseOpsFusionFn</a> = std::function&lt; bool(const <a class="el" href="classmlir_1_1OpResult.html">OpResult</a> &amp;producer, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;consumer)&gt;</td></tr>
<tr class="memdesc:a7f0c7d5683991009cfddd7748b7f8d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type which is used to control when to stop fusion.  <a href="#a7f0c7d5683991009cfddd7748b7f8d4d">More...</a><br /></td></tr>
<tr class="separator:a7f0c7d5683991009cfddd7748b7f8d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f98a29e8d8529d00b3b406f009767e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a15f98a29e8d8529d00b3b406f009767e">AllocBufferCallbackFn</a> = std::function&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, memref::SubViewOp subView, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; boundingSubViewSize, <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;layout)&gt;</td></tr>
<tr class="memdesc:a15f98a29e8d8529d00b3b406f009767e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to perform the allocation for the promoted <code>subView</code>.  <a href="#a15f98a29e8d8529d00b3b406f009767e">More...</a><br /></td></tr>
<tr class="separator:a15f98a29e8d8529d00b3b406f009767e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7afb284c4be072a74a24eeb71cc985"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3d7afb284c4be072a74a24eeb71cc985">DeallocBufferCallbackFn</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> buffer)&gt;</td></tr>
<tr class="memdesc:a3d7afb284c4be072a74a24eeb71cc985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to deallocate the buffers used to hold the promoted subview.  <a href="#a3d7afb284c4be072a74a24eeb71cc985">More...</a><br /></td></tr>
<tr class="separator:a3d7afb284c4be072a74a24eeb71cc985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49994e2aab61b35167972384684cf24"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa49994e2aab61b35167972384684cf24">CopyCallbackFn</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> src, <a class="el" href="classmlir_1_1Value.html">Value</a> dst)&gt;</td></tr>
<tr class="memdesc:aa49994e2aab61b35167972384684cf24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to insert copy from original subview to subview of the promoted region for the read operands/subview of promoted region to original subview for the results.  <a href="#aa49994e2aab61b35167972384684cf24">More...</a><br /></td></tr>
<tr class="separator:aa49994e2aab61b35167972384684cf24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730df0415b8172eb93f8f7b346e04440"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a730df0415b8172eb93f8f7b346e04440">TileSizeComputationFunction</a> = std::function&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td></tr>
<tr class="separator:a730df0415b8172eb93f8f7b346e04440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e35b70fe918b19be8809c7f86dba8b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a24e35b70fe918b19be8809c7f86dba8b">PaddingValueComputationFunction</a> = std::function&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a24e35b70fe918b19be8809c7f86dba8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the padding value for an <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation. ">OpOperand</a>.  <a href="#a24e35b70fe918b19be8809c7f86dba8b">More...</a><br /></td></tr>
<tr class="separator:a24e35b70fe918b19be8809c7f86dba8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b1e68a26156715923bbc38afddff82"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a54b1e68a26156715923bbc38afddff82"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a54b1e68a26156715923bbc38afddff82">has_get_operation_name</a> = decltype(T::getOperationName())</td></tr>
<tr class="memdesc:a54b1e68a26156715923bbc38afddff82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if T provides a <code>getOperationName</code> method.  <a href="#a54b1e68a26156715923bbc38afddff82">More...</a><br /></td></tr>
<tr class="separator:a54b1e68a26156715923bbc38afddff82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba4b4e6dc3c816c9b069a2c40c97420"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4ba4b4e6dc3c816c9b069a2c40c97420"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4ba4b4e6dc3c816c9b069a2c40c97420">detect_has_get_operation_name</a> = llvm::is_detected&lt; <a class="el" href="namespacemlir_1_1linalg.html#a54b1e68a26156715923bbc38afddff82">has_get_operation_name</a>, T &gt;</td></tr>
<tr class="separator:a4ba4b4e6dc3c816c9b069a2c40c97420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f14b7de232347900daf39a27a2725b1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7f14b7de232347900daf39a27a2725b1">OptimizeCopyFn</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;, PadTensorOp, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;</td></tr>
<tr class="separator:a7f14b7de232347900daf39a27a2725b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f1b76eab74d8bc4ba354b1c6e67a6b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a26f1b76eab74d8bc4ba354b1c6e67a6b">GetMinMaxExprFn</a> = std::function&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; std::pair&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &gt;(<a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;dims, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;symbols)&gt;</td></tr>
<tr class="separator:a26f1b76eab74d8bc4ba354b1c6e67a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2c8e52c82709202bade005c0609f77"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aed2c8e52c82709202bade005c0609f77">FusableOpDependencesTy</a> = llvm::MapVector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1LinalgDependenceGraph_1_1LinalgDependenceGraphElem.html">LinalgDependenceGraph::LinalgDependenceGraphElem</a>, 1 &gt; &gt;</td></tr>
<tr class="separator:aed2c8e52c82709202bade005c0609f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a0b220b224fc8b91b37ee63b95a12f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a60a0b220b224fc8b91b37ee63b95a12f">ProcInfoCallBackFn</a> = std::function&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1ProcInfo.html">ProcInfo</a>, 2 &gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> <a class="el" href="VectorTransforms_8cpp.html#ae4994638b2651e4ee3cf1a8d9dd64947">loc</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; parallelLoopRanges)&gt;</td></tr>
<tr class="separator:a60a0b220b224fc8b91b37ee63b95a12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43919709cf99a429d1b9e995f6cb555e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a43919709cf99a429d1b9e995f6cb555e">OneDimProcInfoCallBackFn</a> = std::function&lt; <a class="el" href="structmlir_1_1linalg_1_1ProcInfo.html">ProcInfo</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> <a class="el" href="VectorTransforms_8cpp.html#ae4994638b2651e4ee3cf1a8d9dd64947">loc</a>)&gt;</td></tr>
<tr class="separator:a43919709cf99a429d1b9e995f6cb555e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a3cdd229e1459c7e6ed2f9c7ee7168325"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325">LinalgTilingLoopType</a> { <a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325a4b2257cb98694284507e77f34e73c2d8">LinalgTilingLoopType::Loops</a> = 0, 
<a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325a6d8bf0bdeaca5ef4693524bf04c4c877">LinalgTilingLoopType::AffineLoops</a> = 1, 
<a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325ab92546344b4e3fa9b10c9472795297a7">LinalgTilingLoopType::ParallelLoops</a> = 2, 
<a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325a695eb12d246fdee4efda9a552f92406e">LinalgTilingLoopType::TiledLoops</a> = 3
 }<tr class="memdesc:a3cdd229e1459c7e6ed2f9c7ee7168325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg tiling patterns.  <a href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a3cdd229e1459c7e6ed2f9c7ee7168325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98153087b663d0d7aa3ab0685cfaedaf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedaf">LinalgLoweringType</a> { <a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedafaaf6ba7cc968a74a4d611c3ab0148b33c">LinalgLoweringType::LibraryCall</a> = 0, 
<a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedafa4b2257cb98694284507e77f34e73c2d8">LinalgLoweringType::Loops</a> = 1, 
<a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedafa6d8bf0bdeaca5ef4693524bf04c4c877">LinalgLoweringType::AffineLoops</a> = 2, 
<a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedafab92546344b4e3fa9b10c9472795297a7">LinalgLoweringType::ParallelLoops</a> = 3
 }<tr class="memdesc:a98153087b663d0d7aa3ab0685cfaedaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg lowering patterns.  <a href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedaf">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a98153087b663d0d7aa3ab0685cfaedaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7382d59369873eb3a9a9ddd571056982"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982">DistributionMethod</a> { <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982ad71670d62b238eaf063979407361034e">DistributionMethod::Cyclic</a> = 0, 
<a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982abab54876ff518ecd2d59b46fd3be9c0e">DistributionMethod::CyclicNumProcsGeNumIters</a> = 1, 
<a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982ad93606014b9a6b479ba0e6faa948540b">DistributionMethod::CyclicNumProcsEqNumIters</a> = 2
 }<tr class="memdesc:a7382d59369873eb3a9a9ddd571056982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheme used to distribute loops to processors.  <a href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a7382d59369873eb3a9a9ddd571056982"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a703d4f21c6f57b8c680dc20dd6928a61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a703d4f21c6f57b8c680dc20dd6928a61">populateLinalgToStandardConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a703d4f21c6f57b8c680dc20dd6928a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from Linalg to Standard.  <a href="#a703d4f21c6f57b8c680dc20dd6928a61">More...</a><br /></td></tr>
<tr class="separator:a703d4f21c6f57b8c680dc20dd6928a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f3fb54af9cdc66ff265b44a17a5df4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a67f3fb54af9cdc66ff265b44a17a5df4">applyMapToValues</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> <a class="el" href="VectorTransforms_8cpp.html#ae4994638b2651e4ee3cf1a8d9dd64947">loc</a>, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> <a class="el" href="ComprehensiveBufferize_8cpp.html#a2ca7063639bfcde8e71436b396374864">map</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values)</td></tr>
<tr class="memdesc:a67f3fb54af9cdc66ff265b44a17a5df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the values obtained by applying <code>map</code> to the list of values.  <a href="#a67f3fb54af9cdc66ff265b44a17a5df4">More...</a><br /></td></tr>
<tr class="separator:a67f3fb54af9cdc66ff265b44a17a5df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5277093c168682f123f1e99d90461f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab5277093c168682f123f1e99d90461f0">isaContractionOpInterface</a> (LinalgOp linalgOp)</td></tr>
<tr class="memdesc:ab5277093c168682f123f1e99d90461f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>linalgOp</code> conforms to ContractionOpInterface.  <a href="#ab5277093c168682f123f1e99d90461f0">More...</a><br /></td></tr>
<tr class="separator:ab5277093c168682f123f1e99d90461f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9aac538302681e906bd4261c128d90e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1linalg.html#a949f3c7a426d9e0cfec01467631f8037">LoopRangeBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af9aac538302681e906bd4261c128d90e">defaultLoopRangesBuilder</a> (LinalgOp <a class="el" href="VectorTransforms_8cpp.html#a82351822256877c618afdca2c8c57755">op</a>)</td></tr>
<tr class="memdesc:af9aac538302681e906bd4261c128d90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a very simple inference procedure to build the loop ranges from the op and its operands.  <a href="#af9aac538302681e906bd4261c128d90e">More...</a><br /></td></tr>
<tr class="separator:af9aac538302681e906bd4261c128d90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754ec5c5960c640563ddcd9727b77d87"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a754ec5c5960c640563ddcd9727b77d87">generateLibraryCallName</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *<a class="el" href="VectorTransforms_8cpp.html#a82351822256877c618afdca2c8c57755">op</a>)</td></tr>
<tr class="memdesc:a754ec5c5960c640563ddcd9727b77d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name mangled library call name to disambiguate between different overloads at the C level.  <a href="#a754ec5c5960c640563ddcd9727b77d87">More...</a><br /></td></tr>
<tr class="separator:a754ec5c5960c640563ddcd9727b77d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962a46fba2ac497e30bb6d23fef35d1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a962a46fba2ac497e30bb6d23fef35d1a">makeAffineDimExprs</a> (<a class="el" href="classunsigned.html">unsigned</a> num, <a class="el" href="classunsigned.html">unsigned</a> &amp;startIdx, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a962a46fba2ac497e30bb6d23fef35d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>num</code> <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression. ">AffineDimExpr</a> dimensions at positions [startIdx, startIdx + num) and increments <code>startIdx</code> to <code>startIdx + num</code>.  <a href="#a962a46fba2ac497e30bb6d23fef35d1a">More...</a><br /></td></tr>
<tr class="separator:a962a46fba2ac497e30bb6d23fef35d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5dd029acdda95eeb6887d0e169bcbb5"><td class="memTemplParams" colspan="2">template&lt;typename PoolingOp &gt; </td></tr>
<tr class="memitem:ab5dd029acdda95eeb6887d0e169bcbb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab5dd029acdda95eeb6887d0e169bcbb5">weightedPoolingInputIndex</a> (PoolingOp <a class="el" href="VectorTransforms_8cpp.html#a82351822256877c618afdca2c8c57755">op</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; outputDims, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; windowDims)</td></tr>
<tr class="memdesc:ab5dd029acdda95eeb6887d0e169bcbb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds the indexing expressions for a ConvOp/PoolingOp <code>op</code>.  <a href="#ab5dd029acdda95eeb6887d0e169bcbb5">More...</a><br /></td></tr>
<tr class="separator:ab5dd029acdda95eeb6887d0e169bcbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddca37c4e3bf09cb06fc5197380bde3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a6ddca37c4e3bf09cb06fc5197380bde3">extractOrIdentityMap</a> (<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maybeMap, <a class="el" href="classunsigned.html">unsigned</a> rank, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a6ddca37c4e3bf09cb06fc5197380bde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>maybeMap.get()</code> if <code>maybeMap</code> is set, otherwise returns the symbol-less identity map of <code>rank</code>.  <a href="#a6ddca37c4e3bf09cb06fc5197380bde3">More...</a><br /></td></tr>
<tr class="separator:a6ddca37c4e3bf09cb06fc5197380bde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8ea0aae80d24eeffa3fef8f1f08c43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4f8ea0aae80d24eeffa3fef8f1f08c43">concat</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; a, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; b)</td></tr>
<tr class="memdesc:a4f8ea0aae80d24eeffa3fef8f1f08c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector that is the concatenation of <code>a</code> and <code>b</code>.  <a href="#a4f8ea0aae80d24eeffa3fef8f1f08c43">More...</a><br /></td></tr>
<tr class="separator:a4f8ea0aae80d24eeffa3fef8f1f08c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504d0107ce313528b9b8b2ecefb43e38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a504d0107ce313528b9b8b2ecefb43e38">getDimsOfType</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *<a class="el" href="VectorTransforms_8cpp.html#a82351822256877c618afdca2c8c57755">op</a>, StringRef iteratorTypeName, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &amp;res)</td></tr>
<tr class="memdesc:a504d0107ce313528b9b8b2ecefb43e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dims that are <code>iteratorTypeName</code> loops in the LinalgOp <code>op</code>.  <a href="#a504d0107ce313528b9b8b2ecefb43e38">More...</a><br /></td></tr>
<tr class="separator:a504d0107ce313528b9b8b2ecefb43e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15aaf2258ce2e092c635d257d0bc276"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class PatternType, typename ConcreteOpType , typename OptionsType , typename  = std::enable_if_t&lt;std::is_member_function_pointer&lt;              decltype(&amp;ConcreteOpType::getOperationName)&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ae15aaf2258ce2e092c635d257d0bc276"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae15aaf2258ce2e092c635d257d0bc276">sfinae_enqueue</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patternList, OptionsType <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, StringRef opName, <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a> m)</td></tr>
<tr class="memdesc:ae15aaf2258ce2e092c635d257d0bc276"><td class="mdescLeft">&#160;</td><td class="mdescRight">SFINAE: Enqueue helper for ConcreteOpType that have a <code>getOperationName</code>.  <a href="#ae15aaf2258ce2e092c635d257d0bc276">More...</a><br /></td></tr>
<tr class="separator:ae15aaf2258ce2e092c635d257d0bc276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a3ec018fb2c3f8170acbd560b0044c"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class PatternType, typename OpType , typename OptionsType &gt; </td></tr>
<tr class="memitem:a46a3ec018fb2c3f8170acbd560b0044c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a46a3ec018fb2c3f8170acbd560b0044c">sfinae_enqueue</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patternList, OptionsType <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, StringRef opName, <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a> m)</td></tr>
<tr class="memdesc:a46a3ec018fb2c3f8170acbd560b0044c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SFINAE: Enqueue helper for OpType that do not have a <code>getOperationName</code> (e.g.  <a href="#a46a3ec018fb2c3f8170acbd560b0044c">More...</a><br /></td></tr>
<tr class="separator:a46a3ec018fb2c3f8170acbd560b0044c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61cc9e0c28375cb013346496eb9b6227"><td class="memTemplParams" colspan="2">template&lt;typename PatternType , typename OpType , typename OptionsType &gt; </td></tr>
<tr class="memitem:a61cc9e0c28375cb013346496eb9b6227"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a61cc9e0c28375cb013346496eb9b6227">enqueue</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patternList, OptionsType <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, StringRef opName, <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a> m)</td></tr>
<tr class="separator:a61cc9e0c28375cb013346496eb9b6227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc911548f9f0328faf5855ab880e7bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#afbc911548f9f0328faf5855ab880e7bc">hoistRedundantVectorTransfers</a> (FuncOp func)</td></tr>
<tr class="memdesc:afbc911548f9f0328faf5855ab880e7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hoist vector.transfer_read/vector.transfer_write on buffers pairs out of immediately enclosing scf::ForOp iteratively, if the following conditions are true:  <a href="#afbc911548f9f0328faf5855ab880e7bc">More...</a><br /></td></tr>
<tr class="separator:afbc911548f9f0328faf5855ab880e7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128bb6b2ac6de56efa82fb01ae3f258e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a128bb6b2ac6de56efa82fb01ae3f258e">hoistRedundantVectorTransfersOnTensor</a> (FuncOp func)</td></tr>
<tr class="memdesc:a128bb6b2ac6de56efa82fb01ae3f258e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same behavior as <code>hoistRedundantVectorTransfers</code> but works on tensors instead of buffers.  <a href="#a128bb6b2ac6de56efa82fb01ae3f258e">More...</a><br /></td></tr>
<tr class="separator:a128bb6b2ac6de56efa82fb01ae3f258e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7224b24d57b2f395595d661d846257"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3a7224b24d57b2f395595d661d846257">hoistPaddingOnTensors</a> (PadTensorOp &amp;padTensorOp, <a class="el" href="classunsigned.html">unsigned</a> nLoops)</td></tr>
<tr class="memdesc:a3a7224b24d57b2f395595d661d846257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mechanically hoist padding operations on tensors by <code>nLoops</code> into a new, generally larger tensor.  <a href="#a3a7224b24d57b2f395595d661d846257">More...</a><br /></td></tr>
<tr class="separator:a3a7224b24d57b2f395595d661d846257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae949a412565c20b3d334a8d3a26acab3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae949a412565c20b3d334a8d3a26acab3">skipUnitDimReshape</a> (const <a class="el" href="classmlir_1_1OpResult.html">OpResult</a> &amp;producer, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;consumer)</td></tr>
<tr class="memdesc:ae949a412565c20b3d334a8d3a26acab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default function to control reshape folding.  <a href="#ae949a412565c20b3d334a8d3a26acab3">More...</a><br /></td></tr>
<tr class="separator:ae949a412565c20b3d334a8d3a26acab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09260a76a605cbb154f1a4d802feeea9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a09260a76a605cbb154f1a4d802feeea9">populateConvVectorizationPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &gt; &amp;patterns, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; tileSizes)</td></tr>
<tr class="memdesc:a09260a76a605cbb154f1a4d802feeea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns for vectorization of all ConvN-D ops.  <a href="#a09260a76a605cbb154f1a4d802feeea9">More...</a><br /></td></tr>
<tr class="separator:a09260a76a605cbb154f1a4d802feeea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a49133ef595966377878adc42196f47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7a49133ef595966377878adc42196f47">populateElementwiseToLinalgConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a7a49133ef595966377878adc42196f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns that convert <code>ElementwiseMappable</code> ops to linalg parallel loops.  <a href="#a7a49133ef595966377878adc42196f47">More...</a><br /></td></tr>
<tr class="separator:a7a49133ef595966377878adc42196f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6b7bc78a3dd3530d45e50a15e48af5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5b6b7bc78a3dd3530d45e50a15e48af5">populateFoldReshapeOpsByExpansionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="namespacemlir_1_1linalg.html#a7f0c7d5683991009cfddd7748b7f8d4d">ControlElementwiseOpsFusionFn</a> controlFoldingReshapes=<a class="el" href="namespacemlir_1_1linalg.html#ae949a412565c20b3d334a8d3a26acab3">skipUnitDimReshape</a>)</td></tr>
<tr class="memdesc:a5b6b7bc78a3dd3530d45e50a15e48af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold an expanding (collapsing) tensor_reshape operation with its producer (consumer) generic operation by expanding the dimensionality of the loop in the generic op.  <a href="#a5b6b7bc78a3dd3530d45e50a15e48af5">More...</a><br /></td></tr>
<tr class="separator:a5b6b7bc78a3dd3530d45e50a15e48af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83456e96c4abd883654638b15422f2f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a83456e96c4abd883654638b15422f2f7">populateFoldReshapeOpsByLinearizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a83456e96c4abd883654638b15422f2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold a collapsing (expanding) tensor_reshape operation with its producer (consumer) generic operation by linearizing the indexing map used to access the source (target) of the reshape operation in the generic operation.  <a href="#a83456e96c4abd883654638b15422f2f7">More...</a><br /></td></tr>
<tr class="separator:a83456e96c4abd883654638b15422f2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab9722666a91e7e3d5e93b24bb9f8f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aaab9722666a91e7e3d5e93b24bb9f8f2">populateFoldUnitDimsReshapeOpsByLinearizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:aaab9722666a91e7e3d5e93b24bb9f8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold a collapsing (expanding) tensor_reshape operation with its producer (consumer) generic operation by linearizing the indexing map used to access the source (target) of the reshape operation in the generic operation.  <a href="#aaab9722666a91e7e3d5e93b24bb9f8f2">More...</a><br /></td></tr>
<tr class="separator:aaab9722666a91e7e3d5e93b24bb9f8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a371b7b0b87abfdcef373c3ac312a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa5a371b7b0b87abfdcef373c3ac312a8">populateLinalgBufferizePatterns</a> (<a class="el" href="classmlir_1_1BufferizeTypeConverter.html">BufferizeTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:aa5a371b7b0b87abfdcef373c3ac312a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the given list with patterns to bufferize linalg ops.  <a href="#aa5a371b7b0b87abfdcef373c3ac312a8">More...</a><br /></td></tr>
<tr class="separator:aa5a371b7b0b87abfdcef373c3ac312a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1578d606ad73b93f532062fef0ce6574"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1578d606ad73b93f532062fef0ce6574">populateFoldUnitExtentDimsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a1578d606ad73b93f532062fef0ce6574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold unit-extent dimensions in operands/results of linalg ops on tensors.  <a href="#a1578d606ad73b93f532062fef0ce6574">More...</a><br /></td></tr>
<tr class="separator:a1578d606ad73b93f532062fef0ce6574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc64a8c8a9ecf3de84383893d8e4ddc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#acc64a8c8a9ecf3de84383893d8e4ddc2">populateInlineConstantOperandsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:acc64a8c8a9ecf3de84383893d8e4ddc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns that are used to inline constant operands into linalg generic ops.  <a href="#acc64a8c8a9ecf3de84383893d8e4ddc2">More...</a><br /></td></tr>
<tr class="separator:acc64a8c8a9ecf3de84383893d8e4ddc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141726cc3e876dde26944874a419e36c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a141726cc3e876dde26944874a419e36c">populateTiledLoopToSCFPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a141726cc3e876dde26944874a419e36c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to convert TiledLoopOp to SCF loops.  <a href="#a141726cc3e876dde26944874a419e36c">More...</a><br /></td></tr>
<tr class="separator:a141726cc3e876dde26944874a419e36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f808101854ba4429cc752879269e28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a46f808101854ba4429cc752879269e28">populateElementwiseOpsFusionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="structmlir_1_1linalg_1_1LinalgElementwiseFusionOptions.html">LinalgElementwiseFusionOptions</a> <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>=<a class="el" href="structmlir_1_1linalg_1_1LinalgElementwiseFusionOptions.html">LinalgElementwiseFusionOptions</a>())</td></tr>
<tr class="memdesc:a46f808101854ba4429cc752879269e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns for fusing linalg operation on tensors.  <a href="#a46f808101854ba4429cc752879269e28">More...</a><br /></td></tr>
<tr class="separator:a46f808101854ba4429cc752879269e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8660b99b3f1cd3f42085e6c6694b0a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae8660b99b3f1cd3f42085e6c6694b0a0">populatePushReshapeOpsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ae8660b99b3f1cd3f42085e6c6694b0a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to push reshape op towards the end of the graph in order to expose more fusion opportunities.  <a href="#ae8660b99b3f1cd3f42085e6c6694b0a0">More...</a><br /></td></tr>
<tr class="separator:ae8660b99b3f1cd3f42085e6c6694b0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2efdb9223f206f2d1f8f8ee6b27564f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">TiledLinalgOp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab2efdb9223f206f2d1f8f8ee6b27564f">tileLinalgOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, LinalgOp <a class="el" href="VectorTransforms_8cpp.html#a82351822256877c618afdca2c8c57755">op</a>, const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="separator:ab2efdb9223f206f2d1f8f8ee6b27564f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0dffca46cdba77603c5b6b113d5c7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1TiledAndFusedLinalgOps.html">TiledAndFusedLinalgOps</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a0d0dffca46cdba77603c5b6b113d5c7a">tileAndFuseLinalgOps</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LinalgOp &gt; ops, const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;dependenceGraph, const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;tilingOptions)</td></tr>
<tr class="separator:a0d0dffca46cdba77603c5b6b113d5c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4223ee2d6488e478b0a9e86897094a9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4223ee2d6488e478b0a9e86897094a9a">interchangeGenericOp</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;<a class="el" href="VectorTransforms_8cpp.html#ad5f83d2f1076dd9edf5d9064e4febb82">rewriter</a>, GenericOp genericOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; interchangeVector)</td></tr>
<tr class="memdesc:a4223ee2d6488e478b0a9e86897094a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interchanges the <code>iterator_types</code> and <code>iterator_maps</code> dimensions and adapts the index accesses of <code>op</code>.  <a href="#a4223ee2d6488e478b0a9e86897094a9a">More...</a><br /></td></tr>
<tr class="separator:a4223ee2d6488e478b0a9e86897094a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56a19420366b42fc7ead95445775b3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1PromotionInfo.html">PromotionInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa56a19420366b42fc7ead95445775b3a">promoteSubviewAsNewBuffer</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> <a class="el" href="VectorTransforms_8cpp.html#ae4994638b2651e4ee3cf1a8d9dd64947">loc</a>, memref::SubViewOp subView, <a class="el" href="namespacemlir_1_1linalg.html#a15f98a29e8d8529d00b3b406f009767e">AllocBufferCallbackFn</a> allocationFn, <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;layout)</td></tr>
<tr class="separator:aa56a19420366b42fc7ead95445775b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc074a275eb7463fb59cf548d25f6d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; LinalgOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aecc074a275eb7463fb59cf548d25f6d4">promoteSubViews</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, LinalgOp <a class="el" href="VectorTransforms_8cpp.html#a82351822256877c618afdca2c8c57755">op</a>, <a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a> <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:aecc074a275eb7463fb59cf548d25f6d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes the <code>subViews</code> into a new buffer allocated at the insertion point <code>b</code>.  <a href="#aecc074a275eb7463fb59cf548d25f6d4">More...</a><br /></td></tr>
<tr class="separator:aecc074a275eb7463fb59cf548d25f6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafecf344e928b95496d372d78ae592a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aafecf344e928b95496d372d78ae592a0">vectorizeLinalgOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *<a class="el" href="VectorTransforms_8cpp.html#a82351822256877c618afdca2c8c57755">op</a>, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;newResults)</td></tr>
<tr class="memdesc:aafecf344e928b95496d372d78ae592a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a suitable vector form for a Linalg op with fully static shape.  <a href="#aafecf344e928b95496d372d78ae592a0">More...</a><br /></td></tr>
<tr class="separator:aafecf344e928b95496d372d78ae592a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742f1b413a8aa1536e1e281946ee0984"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a742f1b413a8aa1536e1e281946ee0984">linalgOpToLoops</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;<a class="el" href="VectorTransforms_8cpp.html#ad5f83d2f1076dd9edf5d9064e4febb82">rewriter</a>, LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a742f1b413a8aa1536e1e281946ee0984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits a loop nest of <code>scf.for</code> with the proper body for <code>linalgOp</code>.  <a href="#a742f1b413a8aa1536e1e281946ee0984">More...</a><br /></td></tr>
<tr class="separator:a742f1b413a8aa1536e1e281946ee0984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217fdb304b3bca1db824e4a3a2903732"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a217fdb304b3bca1db824e4a3a2903732">linalgOpToParallelLoops</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;<a class="el" href="VectorTransforms_8cpp.html#ad5f83d2f1076dd9edf5d9064e4febb82">rewriter</a>, LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a217fdb304b3bca1db824e4a3a2903732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits a loop nest of <code>scf.parallel</code> with the proper body for <code>linalgOp</code>.  <a href="#a217fdb304b3bca1db824e4a3a2903732">More...</a><br /></td></tr>
<tr class="separator:a217fdb304b3bca1db824e4a3a2903732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfc5511c5ab572fb035439d107da67d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aecfc5511c5ab572fb035439d107da67d">linalgOpToAffineLoops</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;<a class="el" href="VectorTransforms_8cpp.html#ad5f83d2f1076dd9edf5d9064e4febb82">rewriter</a>, LinalgOp linalgOp)</td></tr>
<tr class="memdesc:aecfc5511c5ab572fb035439d107da67d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits a loop nest of <code>affine.for</code> with the proper body for <code>linalgOp</code>.  <a href="#aecfc5511c5ab572fb035439d107da67d">More...</a><br /></td></tr>
<tr class="separator:aecfc5511c5ab572fb035439d107da67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af1c8a390189f7f1882bfd1181f8112"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a9af1c8a390189f7f1882bfd1181f8112">interchangeGenericOpPrecondition</a> (GenericOp genericOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; interchangeVector)</td></tr>
<tr class="memdesc:a9af1c8a390189f7f1882bfd1181f8112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits a <code>generic</code> operation with the <code>indexing_maps</code> and <code>iterator_types</code> permutated according to <code>permutation</code>.  <a href="#a9af1c8a390189f7f1882bfd1181f8112">More...</a><br /></td></tr>
<tr class="separator:a9af1c8a390189f7f1882bfd1181f8112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850b9fd11404efe17bca02011aff2e88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a850b9fd11404efe17bca02011aff2e88">promoteSubviewsPrecondition</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *<a class="el" href="VectorTransforms_8cpp.html#a82351822256877c618afdca2c8c57755">op</a>, <a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a> <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a850b9fd11404efe17bca02011aff2e88"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1linalg_1_1Promote.html" title="Promotion transformation enqueues a particular stage-1 pattern for Promote&lt;LinalgOpType&gt;with the appr...">Promote</a> std.subviews feeding linalg operations.  <a href="#a850b9fd11404efe17bca02011aff2e88">More...</a><br /></td></tr>
<tr class="separator:a850b9fd11404efe17bca02011aff2e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434bd78a651f6a42d01090db72bc039c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a434bd78a651f6a42d01090db72bc039c">vectorizeLinalgOpPrecondition</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *<a class="el" href="VectorTransforms_8cpp.html#a82351822256877c618afdca2c8c57755">op</a>)</td></tr>
<tr class="memdesc:a434bd78a651f6a42d01090db72bc039c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite a linalg.generic into a suitable vector.contraction op.  <a href="#a434bd78a651f6a42d01090db72bc039c">More...</a><br /></td></tr>
<tr class="separator:a434bd78a651f6a42d01090db72bc039c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61503376ad6b88f0c35f8ce358dbc9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae61503376ad6b88f0c35f8ce358dbc9e">getLinalgTilingCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:ae61503376ad6b88f0c35f8ce358dbc9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalization patterns relevant to apply after tiling patterns.  <a href="#ae61503376ad6b88f0c35f8ce358dbc9e">More...</a><br /></td></tr>
<tr class="separator:ae61503376ad6b88f0c35f8ce358dbc9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4701ad0fa2e34da0089a80135935f02e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4701ad0fa2e34da0089a80135935f02e">populateLinalgTilingCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a4701ad0fa2e34da0089a80135935f02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770981e996593487fafc3a47ac9c4be9"><td class="memTemplParams" colspan="2">template&lt;typename OpType , typename  = std::enable_if_t&lt;detect_has_get_operation_name&lt;OpType&gt;::value&gt;, typename  = void&gt; </td></tr>
<tr class="memitem:a770981e996593487fafc3a47ac9c4be9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a770981e996593487fafc3a47ac9c4be9">insertVectorizationPatternImpl</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patternList, <a class="el" href="structmlir_1_1linalg_1_1LinalgVectorizationOptions.html">linalg::LinalgVectorizationOptions</a> <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a> f)</td></tr>
<tr class="memdesc:a770981e996593487fafc3a47ac9c4be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">SFINAE helper for single C++ op with a <code>getOperationName</code> method.  <a href="#a770981e996593487fafc3a47ac9c4be9">More...</a><br /></td></tr>
<tr class="separator:a770981e996593487fafc3a47ac9c4be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b512a9592500c7fb570fea733d3591f"><td class="memTemplParams" colspan="2">template&lt;typename OpType , typename  = std::enable_if_t&lt;                               !detect_has_get_operation_name&lt;OpType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a7b512a9592500c7fb570fea733d3591f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7b512a9592500c7fb570fea733d3591f">insertVectorizationPatternImpl</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patternList, <a class="el" href="structmlir_1_1linalg_1_1LinalgVectorizationOptions.html">linalg::LinalgVectorizationOptions</a> <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a> f)</td></tr>
<tr class="memdesc:a7b512a9592500c7fb570fea733d3591f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SFINAE helper for single C++ class without a <code>getOperationName</code> method (e.g.  <a href="#a7b512a9592500c7fb570fea733d3591f">More...</a><br /></td></tr>
<tr class="separator:a7b512a9592500c7fb570fea733d3591f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d3a5c3a62ba42651c654bac998b69e"><td class="memTemplParams" colspan="2">template&lt;typename... OpTypes&gt; </td></tr>
<tr class="memitem:ab6d3a5c3a62ba42651c654bac998b69e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab6d3a5c3a62ba42651c654bac998b69e">insertVectorizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patternList, <a class="el" href="structmlir_1_1linalg_1_1LinalgVectorizationOptions.html">linalg::LinalgVectorizationOptions</a> <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a> f=<a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>())</td></tr>
<tr class="memdesc:ab6d3a5c3a62ba42651c654bac998b69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic helper function to insert vectorization patterns for C++ ops.  <a href="#ab6d3a5c3a62ba42651c654bac998b69e">More...</a><br /></td></tr>
<tr class="separator:ab6d3a5c3a62ba42651c654bac998b69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60cd962332e381639e396c646c82eb14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a60cd962332e381639e396c646c82eb14">populateLinalgNamedOpsGeneralizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">LinalgTransformationFilter</a> filter=<a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">LinalgTransformationFilter</a>())</td></tr>
<tr class="memdesc:a60cd962332e381639e396c646c82eb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg generalization patterns.  <a href="#a60cd962332e381639e396c646c82eb14">More...</a><br /></td></tr>
<tr class="separator:a60cd962332e381639e396c646c82eb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0ad2d062832055fdca9b113bb54285"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aff0ad2d062832055fdca9b113bb54285">populateLinalgConvGeneralizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">LinalgTransformationFilter</a> filter=<a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">LinalgTransformationFilter</a>())</td></tr>
<tr class="memdesc:aff0ad2d062832055fdca9b113bb54285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>patterns</code> with patterns to convert linalg.conv ops to linalg.generic ops.  <a href="#aff0ad2d062832055fdca9b113bb54285">More...</a><br /></td></tr>
<tr class="separator:aff0ad2d062832055fdca9b113bb54285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc8eeefb74502116e8a8a57d48369a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7bc8eeefb74502116e8a8a57d48369a5">populateLinalgDistributeTiledLoopPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="structmlir_1_1linalg_1_1LinalgLoopDistributionOptions.html">LinalgLoopDistributionOptions</a> &amp;opts, const <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">LinalgTransformationFilter</a> &amp;marker)</td></tr>
<tr class="memdesc:a7bc8eeefb74502116e8a8a57d48369a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg distribution patterns.  <a href="#a7bc8eeefb74502116e8a8a57d48369a5">More...</a><br /></td></tr>
<tr class="separator:a7bc8eeefb74502116e8a8a57d48369a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d99ec53d8d90c200b932f59c1633742"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1d99ec53d8d90c200b932f59c1633742">populatePadTensorOpVectorizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> baseBenefit=1)</td></tr>
<tr class="memdesc:a1d99ec53d8d90c200b932f59c1633742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>patterns</code> with patterns that vectorize linalg.pad_tensor.  <a href="#a1d99ec53d8d90c200b932f59c1633742">More...</a><br /></td></tr>
<tr class="separator:a1d99ec53d8d90c200b932f59c1633742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ed960597938202b576c1a3e01e07ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1linalg_1_1AffineMapAndOperands.html">AffineMapAndOperands</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af2ed960597938202b576c1a3e01e07ed">substituteMin</a> (AffineMinOp affineMinOp, <a class="el" href="namespacemlir_1_1linalg.html#a26f1b76eab74d8bc4ba354b1c6e67a6b">GetMinMaxExprFn</a> getMinMaxExpr)</td></tr>
<tr class="memdesc:af2ed960597938202b576c1a3e01e07ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the dims of the <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> of <code>affineMinOp</code> and substitute dimensions with known range by new expressions involving the min or max expression:  <a href="#af2ed960597938202b576c1a3e01e07ed">More...</a><br /></td></tr>
<tr class="separator:af2ed960597938202b576c1a3e01e07ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b1b3bc58506cfc9153a49ab178cd38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad3b1b3bc58506cfc9153a49ab178cd38">applyStagedPatterns</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *<a class="el" href="VectorTransforms_8cpp.html#a82351822256877c618afdca2c8c57755">op</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &gt; stage1Patterns, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;stage2Patterns, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; stage3Lambda=nullptr)</td></tr>
<tr class="memdesc:ad3b1b3bc58506cfc9153a49ab178cd38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to allow applying rewrite patterns, interleaved with more global transformations, in a staged fashion:  <a href="#ad3b1b3bc58506cfc9153a49ab178cd38">More...</a><br /></td></tr>
<tr class="separator:ad3b1b3bc58506cfc9153a49ab178cd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21c196847c314c07d222ce3f6bdaa8c"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned N&gt; </td></tr>
<tr class="memitem:ad21c196847c314c07d222ce3f6bdaa8c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad21c196847c314c07d222ce3f6bdaa8c">applyPermutationToVector</a> (<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; T, N &gt; &amp;inVec, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; permutation)</td></tr>
<tr class="memdesc:ad21c196847c314c07d222ce3f6bdaa8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the permutation defined by <code>permutation</code> to <code>inVec</code>.  <a href="#ad21c196847c314c07d222ce3f6bdaa8c">More...</a><br /></td></tr>
<tr class="separator:ad21c196847c314c07d222ce3f6bdaa8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f0310fab99c4db7d336dd602f56d1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab4f0310fab99c4db7d336dd602f56d1c">createOrFoldDimOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> <a class="el" href="VectorTransforms_8cpp.html#ae4994638b2651e4ee3cf1a8d9dd64947">loc</a>, <a class="el" href="classmlir_1_1Value.html">Value</a> source, int64_t dim)</td></tr>
<tr class="memdesc:ab4f0310fab99c4db7d336dd602f56d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that creates a memref::DimOp or tensor::DimOp depending on the type of <code>source</code>.  <a href="#ab4f0310fab99c4db7d336dd602f56d1c">More...</a><br /></td></tr>
<tr class="separator:ab4f0310fab99c4db7d336dd602f56d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756a0c2f5771e052c3d9f2b0dad15525"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a756a0c2f5771e052c3d9f2b0dad15525">getDynOperands</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> <a class="el" href="VectorTransforms_8cpp.html#ae4994638b2651e4ee3cf1a8d9dd64947">loc</a>, <a class="el" href="classmlir_1_1Value.html">Value</a> val, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b)</td></tr>
<tr class="memdesc:a756a0c2f5771e052c3d9f2b0dad15525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an operation, retrieves the value of each dynamic dimension through constructing the necessary DimOp operators.  <a href="#a756a0c2f5771e052c3d9f2b0dad15525">More...</a><br /></td></tr>
<tr class="separator:a756a0c2f5771e052c3d9f2b0dad15525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e51b14c2f2e1baf6c168601a59f9da4"><td class="memItemLeft" align="right" valign="top">IntegerAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3e51b14c2f2e1baf6c168601a59f9da4">getSmallestBoundingIndex</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> size)</td></tr>
<tr class="memdesc:a3e51b14c2f2e1baf6c168601a59f9da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>size</code> comes from an AffineMinOp and one of the values of AffineMinOp is a constant then return a new value set to the smallest such constant.  <a href="#a3e51b14c2f2e1baf6c168601a59f9da4">More...</a><br /></td></tr>
<tr class="separator:a3e51b14c2f2e1baf6c168601a59f9da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9742d07020a6835f7a1855ef4f81c294"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a9742d07020a6835f7a1855ef4f81c294">isParallelIteratorType</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="memdesc:a9742d07020a6835f7a1855ef4f81c294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an iterator_type attribute is parallel.  <a href="#a9742d07020a6835f7a1855ef4f81c294">More...</a><br /></td></tr>
<tr class="separator:a9742d07020a6835f7a1855ef4f81c294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bde6d8fa6533d77b1d706654f0f963"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af7bde6d8fa6533d77b1d706654f0f963">isReductionIteratorType</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="memdesc:af7bde6d8fa6533d77b1d706654f0f963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an iterator_type attribute is parallel.  <a href="#af7bde6d8fa6533d77b1d706654f0f963">More...</a><br /></td></tr>
<tr class="separator:af7bde6d8fa6533d77b1d706654f0f963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ecab0d508abda7349407fa91a3b47e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad0ecab0d508abda7349407fa91a3b47e">isWindowIteratorType</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="memdesc:ad0ecab0d508abda7349407fa91a3b47e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an iterator_type attribute is parallel.  <a href="#ad0ecab0d508abda7349407fa91a3b47e">More...</a><br /></td></tr>
<tr class="separator:ad0ecab0d508abda7349407fa91a3b47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2959f54ccc7cabc35c9337f50c0734"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1a2959f54ccc7cabc35c9337f50c0734">isProducerLastWriteOfView</a> (const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;graph, LinalgOp consumer, <a class="el" href="classmlir_1_1Value.html">Value</a> consumedView, LinalgOp producer)</td></tr>
<tr class="memdesc:a1a2959f54ccc7cabc35c9337f50c0734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the specific <code>producer</code> is the last write to exactly the whole <code>consumedView</code>.  <a href="#a1a2959f54ccc7cabc35c9337f50c0734">More...</a><br /></td></tr>
<tr class="separator:a1a2959f54ccc7cabc35c9337f50c0734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf6605778cf3f93537f2bc2e58da089"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a6bf6605778cf3f93537f2bc2e58da089">isFusableInto</a> (const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;graph, LinalgOp consumer, <a class="el" href="classmlir_1_1Value.html">Value</a> consumedView, LinalgOp producer)</td></tr>
<tr class="memdesc:a6bf6605778cf3f93537f2bc2e58da089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether fusing the specific <code>producer</code> of the <code>consumedView</code> is feasible.  <a href="#a6bf6605778cf3f93537f2bc2e58da089">More...</a><br /></td></tr>
<tr class="separator:a6bf6605778cf3f93537f2bc2e58da089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1e20eaab30a94f36bfc76893f7199b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7f1e20eaab30a94f36bfc76893f7199b">computeTileOffsets</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> <a class="el" href="VectorTransforms_8cpp.html#ae4994638b2651e4ee3cf1a8d9dd64947">loc</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ivs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> tileSizes)</td></tr>
<tr class="memdesc:a7f1e20eaab30a94f36bfc76893f7199b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute tile offsets, given a list of loop <code>ivs</code> and <code>tileSizes</code>.  <a href="#a7f1e20eaab30a94f36bfc76893f7199b">More...</a><br /></td></tr>
<tr class="separator:a7f1e20eaab30a94f36bfc76893f7199b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad316c017a79db35cf486ca98aa4b9560"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad316c017a79db35cf486ca98aa4b9560">computeTileSizes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> <a class="el" href="VectorTransforms_8cpp.html#ae4994638b2651e4ee3cf1a8d9dd64947">loc</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ivs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> tileSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizeBounds)</td></tr>
<tr class="memdesc:ad316c017a79db35cf486ca98aa4b9560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute tile sizes, given a list of loop <code>ivs</code>, <code>tileSizes</code> and dimension sizes (<code>sizeBounds</code>).  <a href="#ad316c017a79db35cf486ca98aa4b9560">More...</a><br /></td></tr>
<tr class="separator:ad316c017a79db35cf486ca98aa4b9560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a2c33620e8df50304c417a9bdee36e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac5a2c33620e8df50304c417a9bdee36e">makeTiledShape</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> <a class="el" href="VectorTransforms_8cpp.html#ae4994638b2651e4ee3cf1a8d9dd64947">loc</a>, <a class="el" href="classmlir_1_1Value.html">Value</a> valueToTile, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> tileSizes, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> <a class="el" href="ComprehensiveBufferize_8cpp.html#a2ca7063639bfcde8e71436b396374864">map</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> subShapeSizes)</td></tr>
<tr class="memdesc:ac5a2c33620e8df50304c417a9bdee36e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an extract_slice/subview op for a single <code>valueToTile</code> with <code>builder</code>.  <a href="#ac5a2c33620e8df50304c417a9bdee36e">More...</a><br /></td></tr>
<tr class="separator:ac5a2c33620e8df50304c417a9bdee36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f6409a20cf9ca1db0996f6f3dd4f53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a77f6409a20cf9ca1db0996f6f3dd4f53">makeTiledShapes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> <a class="el" href="VectorTransforms_8cpp.html#ae4994638b2651e4ee3cf1a8d9dd64947">loc</a>, LinalgOp linalgOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; valuesToTile, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ivs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> tileSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizeBounds)</td></tr>
<tr class="memdesc:a77f6409a20cf9ca1db0996f6f3dd4f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates extract_slice/subview ops for all <code>valuesToTile</code> of the given <code>linalgOp</code> with <code>builder</code>, assuming <code>linalgOp</code> is being fused into a loop nest for tiling with the given induction variables <code>ivs</code> and tile sizes <code>tileSizes</code>.  <a href="#a77f6409a20cf9ca1db0996f6f3dd4f53">More...</a><br /></td></tr>
<tr class="separator:a77f6409a20cf9ca1db0996f6f3dd4f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ad74083992ed8c5b3e804e513bdd29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1linalg.html#aed2c8e52c82709202bade005c0609f77">FusableOpDependencesTy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a13ad74083992ed8c5b3e804e513bdd29">findAllFusableDependences</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LinalgOp &gt; ops, const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;dependenceGraph)</td></tr>
<tr class="memdesc:a13ad74083992ed8c5b3e804e513bdd29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all dependences that are fusable.  <a href="#a13ad74083992ed8c5b3e804e513bdd29">More...</a><br /></td></tr>
<tr class="separator:a13ad74083992ed8c5b3e804e513bdd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5951d3211e4e0b1252261d70863bb82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa5951d3211e4e0b1252261d70863bb82">fuseProducerOfBuffer</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;consumerOpOperand, const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;graph)</td></tr>
<tr class="memdesc:aa5951d3211e4e0b1252261d70863bb82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuses producer into consumer if the producer is structurally feasible and the fusion would not violate dependencies.  <a href="#aa5951d3211e4e0b1252261d70863bb82">More...</a><br /></td></tr>
<tr class="separator:aa5951d3211e4e0b1252261d70863bb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda979eb10cc4f400eccd0fa0d594090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#abda979eb10cc4f400eccd0fa0d594090">fuseProducerOfTensor</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;consumerOpOperand)</td></tr>
<tr class="memdesc:abda979eb10cc4f400eccd0fa0d594090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor counterpart of <code>fuseProducerOfBuffer</code>.  <a href="#abda979eb10cc4f400eccd0fa0d594090">More...</a><br /></td></tr>
<tr class="separator:abda979eb10cc4f400eccd0fa0d594090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e177c93e15a8494da207f0cf5c8d1df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8e177c93e15a8494da207f0cf5c8d1df">fuseProducerOfTensor</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1OpResult.html">OpResult</a> producerOpResult, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;consumerOpOperand)</td></tr>
<tr class="memdesc:a8e177c93e15a8494da207f0cf5c8d1df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor counterpart of <code>fuseProducerOfBuffer</code>.  <a href="#a8e177c93e15a8494da207f0cf5c8d1df">More...</a><br /></td></tr>
<tr class="separator:a8e177c93e15a8494da207f0cf5c8d1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb173d5edf56a08ed3610924312dd364"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aeb173d5edf56a08ed3610924312dd364">updateBoundsForCyclicDistribution</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> <a class="el" href="VectorTransforms_8cpp.html#ae4994638b2651e4ee3cf1a8d9dd64947">loc</a>, <a class="el" href="classmlir_1_1Value.html">Value</a> procId, <a class="el" href="classmlir_1_1Value.html">Value</a> nprocs, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;lb, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;ub, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;step)</td></tr>
<tr class="memdesc:aeb173d5edf56a08ed3610924312dd364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the <code>lb</code>, <code>ub</code> and <code>step</code> to get per processor <code>lb</code>, <code>ub</code> and <code>step</code>.  <a href="#aeb173d5edf56a08ed3610924312dd364">More...</a><br /></td></tr>
<tr class="separator:aeb173d5edf56a08ed3610924312dd364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e61b04f528d6ebbe05496f4d6ea4a0e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1e61b04f528d6ebbe05496f4d6ea4a0e">generateParallelLoopNest</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> <a class="el" href="VectorTransforms_8cpp.html#ae4994638b2651e4ee3cf1a8d9dd64947">loc</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> steps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; iteratorTypes, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilderFn, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;ivStorage, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982">DistributionMethod</a> &gt; distributionMethod={})</td></tr>
<tr class="memdesc:a1e61b04f528d6ebbe05496f4d6ea4a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a loop nest consisting of scf.parallel and scf.for, depending on the `iteratorTypes.  <a href="#a1e61b04f528d6ebbe05496f4d6ea4a0e">More...</a><br /></td></tr>
<tr class="separator:a1e61b04f528d6ebbe05496f4d6ea4a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a15f98a29e8d8529d00b3b406f009767e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f98a29e8d8529d00b3b406f009767e">&#9670;&nbsp;</a></span>AllocBufferCallbackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a15f98a29e8d8529d00b3b406f009767e">mlir::linalg::AllocBufferCallbackFn</a> = typedef std::function&lt;<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt;( <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, memref::SubViewOp subView, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; boundingSubViewSize, <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;layout)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function type used to perform the allocation for the promoted <code>subView</code>. </p>
<p>In <code>boundingSubViewsize</code> a best attempt is made to find the smallest constant value for the size of the buffer needed for each dimension. If that is not possible, contains the dynamic size of the subview. The call back should return the buffer to use. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00237">237</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a7f0c7d5683991009cfddd7748b7f8d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f0c7d5683991009cfddd7748b7f8d4d">&#9670;&nbsp;</a></span>ControlElementwiseOpsFusionFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a7f0c7d5683991009cfddd7748b7f8d4d">mlir::linalg::ControlElementwiseOpsFusionFn</a> = typedef std::function&lt;bool(const <a class="el" href="classmlir_1_1OpResult.html">OpResult</a> &amp;producer, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;consumer)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function type which is used to control when to stop fusion. </p>
<p>It is expected that <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation. ">OpOperand</a> is not modified in the callback. The <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation. ">OpOperand</a> is not marked as const to allow callers to use non-const methods. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00056">56</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="aa49994e2aab61b35167972384684cf24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49994e2aab61b35167972384684cf24">&#9670;&nbsp;</a></span>CopyCallbackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#aa49994e2aab61b35167972384684cf24">mlir::linalg::CopyCallbackFn</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> src, <a class="el" href="classmlir_1_1Value.html">Value</a> dst)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function type used to insert copy from original subview to subview of the promoted region for the read operands/subview of promoted region to original subview for the results. </p>
<p>The copy has to happen from <code>src</code> to <code>dst</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00249">249</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a3d7afb284c4be072a74a24eeb71cc985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7afb284c4be072a74a24eeb71cc985">&#9670;&nbsp;</a></span>DeallocBufferCallbackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a3d7afb284c4be072a74a24eeb71cc985">mlir::linalg::DeallocBufferCallbackFn</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> buffer)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function type used to deallocate the buffers used to hold the promoted subview. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00242">242</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a4ba4b4e6dc3c816c9b069a2c40c97420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba4b4e6dc3c816c9b069a2c40c97420">&#9670;&nbsp;</a></span>detect_has_get_operation_name</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a4ba4b4e6dc3c816c9b069a2c40c97420">mlir::linalg::detect_has_get_operation_name</a> = typedef llvm::is_detected&lt;<a class="el" href="namespacemlir_1_1linalg.html#a54b1e68a26156715923bbc38afddff82">has_get_operation_name</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00757">757</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="aed2c8e52c82709202bade005c0609f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed2c8e52c82709202bade005c0609f77">&#9670;&nbsp;</a></span>FusableOpDependencesTy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#aed2c8e52c82709202bade005c0609f77">mlir::linalg::FusableOpDependencesTy</a> = typedef llvm::MapVector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="structmlir_1_1linalg_1_1LinalgDependenceGraph_1_1LinalgDependenceGraphElem.html">LinalgDependenceGraph::LinalgDependenceGraphElem</a>, 1&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00126">126</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a26f1b76eab74d8bc4ba354b1c6e67a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f1b76eab74d8bc4ba354b1c6e67a6b">&#9670;&nbsp;</a></span>GetMinMaxExprFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a26f1b76eab74d8bc4ba354b1c6e67a6b">mlir::linalg::GetMinMaxExprFn</a> = typedef std::function&lt;<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;std::pair&lt;<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&gt; &gt;( <a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; &amp;dims, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; &amp;symbols)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00981">981</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a54b1e68a26156715923bbc38afddff82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b1e68a26156715923bbc38afddff82">&#9670;&nbsp;</a></span>has_get_operation_name</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a54b1e68a26156715923bbc38afddff82">mlir::linalg::has_get_operation_name</a> = typedef decltype(T::getOperationName())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trait to check if T provides a <code>getOperationName</code> method. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00754">754</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a4a9ca79033211e3e53e0eb25a8e9551b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a9ca79033211e3e53e0eb25a8e9551b">&#9670;&nbsp;</a></span>LinalgLoops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">mlir::linalg::LinalgLoops</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00041">41</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a949f3c7a426d9e0cfec01467631f8037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949f3c7a426d9e0cfec01467631f8037">&#9670;&nbsp;</a></span>LoopRangeBuilder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a949f3c7a426d9e0cfec01467631f8037">mlir::linalg::LoopRangeBuilder</a> = typedef std::function&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="structmlir_1_1Range.html">Range</a>, 4&gt;(<a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html">ImplicitLocOpBuilder</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8h_source.html#l00045">45</a> of file <a class="el" href="LinalgOps_8h_source.html">LinalgOps.h</a>.</p>

</div>
</div>
<a id="a43919709cf99a429d1b9e995f6cb555e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43919709cf99a429d1b9e995f6cb555e">&#9670;&nbsp;</a></span>OneDimProcInfoCallBackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a43919709cf99a429d1b9e995f6cb555e">mlir::linalg::OneDimProcInfoCallBackFn</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1linalg_1_1ProcInfo.html">ProcInfo</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> <a class="el" href="VectorTransforms_8cpp.html#ae4994638b2651e4ee3cf1a8d9dd64947">loc</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00218">218</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a7f14b7de232347900daf39a27a2725b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f14b7de232347900daf39a27a2725b1">&#9670;&nbsp;</a></span>OptimizeCopyFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a7f14b7de232347900daf39a27a2725b1">mlir::linalg::OptimizeCopyFn</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;, PadTensorOp, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00890">890</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a24e35b70fe918b19be8809c7f86dba8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e35b70fe918b19be8809c7f86dba8b">&#9670;&nbsp;</a></span>PaddingValueComputationFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a24e35b70fe918b19be8809c7f86dba8b">mlir::linalg::PaddingValueComputationFunction</a> = typedef std::function&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the padding value for an <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation. ">OpOperand</a>. </p>
<p>This should be a function of both the operation and the operand type. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00451">451</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a60a0b220b224fc8b91b37ee63b95a12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a0b220b224fc8b91b37ee63b95a12f">&#9670;&nbsp;</a></span>ProcInfoCallBackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a60a0b220b224fc8b91b37ee63b95a12f">mlir::linalg::ProcInfoCallBackFn</a> = typedef std::function&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="structmlir_1_1linalg_1_1ProcInfo.html">ProcInfo</a>, 2&gt;( <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> <a class="el" href="VectorTransforms_8cpp.html#ae4994638b2651e4ee3cf1a8d9dd64947">loc</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="structmlir_1_1Range.html">Range</a>&gt; parallelLoopRanges)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00216">216</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a730df0415b8172eb93f8f7b346e04440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730df0415b8172eb93f8f7b346e04440">&#9670;&nbsp;</a></span>TileSizeComputationFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a730df0415b8172eb93f8f7b346e04440">mlir::linalg::TileSizeComputationFunction</a> = typedef std::function&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>, 4&gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00446">446</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a7382d59369873eb3a9a9ddd571056982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7382d59369873eb3a9a9ddd571056982">&#9670;&nbsp;</a></span>DistributionMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982">mlir::linalg::DistributionMethod</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scheme used to distribute loops to processors. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7382d59369873eb3a9a9ddd571056982ad71670d62b238eaf063979407361034e"></a>Cyclic&#160;</td><td class="fielddoc"><p>Cyclic distribution where no assumption is made about the dynamic relationship between number of processors and number of iterations of the distributed loop. </p>
<p>Distributes the following loop</p>
<p>scf.parallel (iv) = (lb) to (ub) step (step)</p>
<p>to</p>
<p>scf.parallel(iv)= (lb + procId * step) to (ub) step (step * nprocs) </p>
</td></tr>
<tr><td class="fieldname"><a id="a7382d59369873eb3a9a9ddd571056982abab54876ff518ecd2d59b46fd3be9c0e"></a>CyclicNumProcsGeNumIters&#160;</td><td class="fielddoc"><p>Cyclic distribution where the number of processors can be assumed to be more than or equal to the number of iterations of the distributed loop. </p>
<p>In such cases, a simple in-bounds check is enough (instead of materializing a loop). Distributes the following loop</p>
<p>scf.parallel (iv) = (lb) to (ub) step (step)</p>
<p>to</p>
<p>iv = lb + procId * step cond = cmpi "slt", iv, ub scf.if cond { ... } </p>
</td></tr>
<tr><td class="fieldname"><a id="a7382d59369873eb3a9a9ddd571056982ad93606014b9a6b479ba0e6faa948540b"></a>CyclicNumProcsEqNumIters&#160;</td><td class="fielddoc"><p>Cyclic distribution where the number of processors can be assumed to be equal to the number of iterations of the distributed loop. </p>
<p>In such cases, no bounds check is needed. Distributes the following loop</p>
<p>scf.parallel (iv) = (lb) to (ub) step (step)</p>
<p>to</p>
<p>iv = lb + procId * step </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00169">169</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a98153087b663d0d7aa3ab0685cfaedaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98153087b663d0d7aa3ab0685cfaedaf">&#9670;&nbsp;</a></span>LinalgLoweringType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedaf">mlir::linalg::LinalgLoweringType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Linalg lowering patterns. </p>
<p>Apply the <code>linalgLowerOpToLoops</code> transformation as a pattern. <code>filter</code> controls LinalgTransformMarker matching and update when specified. See <code>linalgLowerOpToLoops</code> for more details. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a98153087b663d0d7aa3ab0685cfaedafaaf6ba7cc968a74a4d611c3ab0148b33c"></a>LibraryCall&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a98153087b663d0d7aa3ab0685cfaedafa4b2257cb98694284507e77f34e73c2d8"></a>Loops&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a98153087b663d0d7aa3ab0685cfaedafa6d8bf0bdeaca5ef4693524bf04c4c877"></a>AffineLoops&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a98153087b663d0d7aa3ab0685cfaedafab92546344b4e3fa9b10c9472795297a7"></a>ParallelLoops&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00800">800</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a3cdd229e1459c7e6ed2f9c7ee7168325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cdd229e1459c7e6ed2f9c7ee7168325">&#9670;&nbsp;</a></span>LinalgTilingLoopType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325">mlir::linalg::LinalgTilingLoopType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Linalg tiling patterns. </p>
<p>Apply the <code>tileLinalgOp</code> transformation as a pattern. <code>filter</code> controls LinalgTransformMarker matching and update when specified. See <code>tileLinalgOp</code> for more details. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3cdd229e1459c7e6ed2f9c7ee7168325a4b2257cb98694284507e77f34e73c2d8"></a>Loops&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3cdd229e1459c7e6ed2f9c7ee7168325a6d8bf0bdeaca5ef4693524bf04c4c877"></a>AffineLoops&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3cdd229e1459c7e6ed2f9c7ee7168325ab92546344b4e3fa9b10c9472795297a7"></a>ParallelLoops&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3cdd229e1459c7e6ed2f9c7ee7168325a695eb12d246fdee4efda9a552f92406e"></a>TiledLoops&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00438">438</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a67f3fb54af9cdc66ff265b44a17a5df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f3fb54af9cdc66ff265b44a17a5df4">&#9670;&nbsp;</a></span>applyMapToValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt; mlir::linalg::applyMapToValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the values obtained by applying <code>map</code> to the list of values. </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00178">178</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgInterfaces_8cpp_source.html#l00169">createFoldedComposedAffineApply()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01042">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00309">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00317">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00313">mlir::AffineMap::getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00326">mlir::AffineMap::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgOps_8cpp_source.html#l01167">getCollapsedOutputDimFromInputShape()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01218">getExpandedOutputDimFromInputShape()</a>, <a class="el" href="Tiling_8cpp_source.html#l00051">makeTiledLoopRanges()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00536">makeTiledShape()</a>, <a class="el" href="Tiling_8cpp_source.html#l00169">tileLinalgOpImpl()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00856">verify()</a>, and <a class="el" href="LinalgInterfaces_8cpp_source.html#l00271">HasAffineDimExprVisitor::visitSymbolExpr()</a>.</p>

</div>
</div>
<a id="ad21c196847c314c07d222ce3f6bdaa8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad21c196847c314c07d222ce3f6bdaa8c">&#9670;&nbsp;</a></span>applyPermutationToVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::applyPermutationToVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>inVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td>
          <td class="paramname"><em>permutation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the permutation defined by <code>permutation</code> to <code>inVec</code>. </p>
<p>Element <code>i</code> in <code>inVec</code> is mapped to location <code>j = permutation[i]</code>. E.g.: for an input vector `inVec = ['a', 'b', 'c']<code>and a permutation vector </code>permutation = [2, 0, 1]<code>, this function leaves</code>inVec = ['c', 'a', 'b']`. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00037">37</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00617">computeTileOffsets()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00631">computeTileSizes()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00163">createOrFoldDimOp()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00173">getDynOperands()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00186">getSmallestBoundingIndex()</a>, <a class="el" href="Fusion_8cpp_source.html#l00325">isFusableInto()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00119">isParallelIteratorType()</a>, <a class="el" href="Fusion_8cpp_source.html#l00301">isProducerLastWriteOfView()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00126">isReductionIteratorType()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00133">isWindowIteratorType()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01288">loc</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00536">makeTiledShape()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00646">makeTiledShapes()</a>, and <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00174">map()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Interchange_8cpp_source.html#l00046">interchangeGenericOp()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00169">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="ad3b1b3bc58506cfc9153a49ab178cd38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b1b3bc58506cfc9153a49ab178cd38">&#9670;&nbsp;</a></span>applyStagedPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::applyStagedPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &gt;&#160;</td>
          <td class="paramname"><em>stage1Patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>stage2Patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;&#160;</td>
          <td class="paramname"><em>stage3Lambda</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to allow applying rewrite patterns, interleaved with more global transformations, in a staged fashion: </p>
<ol type="1">
<li>the first stage consists of a list of <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html" title="This class represents a frozen set of patterns that can be processed by a pattern applicator...">FrozenRewritePatternSet</a>. Each <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html" title="This class represents a frozen set of patterns that can be processed by a pattern applicator...">FrozenRewritePatternSet</a> in this list is applied once, in order.</li>
<li>the second stage consists of a single OwningRewritePattern that is applied greedily until convergence.</li>
<li>the third stage consists of applying a lambda, generally used for non-local transformation effects. This allows creating custom fused transformations where patterns can be ordered and applied at a finer granularity than a sequence of traditional compiler passes. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00468">468</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00238">mlir::applyPatternsAndFoldGreedily()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00038">DBGS</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01079">mlir::linalg::ConvOpVectorization&lt; ConvOp, N &gt;::ConvOpVectorization()</a>, and <a class="el" href="CodegenStrategy_8cpp_source.html#l00029">mlir::linalg::CodegenStrategy::transform()</a>.</p>

</div>
</div>
<a id="a7f1e20eaab30a94f36bfc76893f7199b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1e20eaab30a94f36bfc76893f7199b">&#9670;&nbsp;</a></span>computeTileOffsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::computeTileOffsets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ivs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>tileSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute tile offsets, given a list of loop <code>ivs</code> and <code>tileSizes</code>. </p>
<p>In case a tile size is zero (i.e., no tiling), the corresponding offset is also zero. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00617">617</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00396">mlir::OpBuilder::create()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00074">isTiled()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00039">isZero()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00037">applyPermutationToVector()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00646">makeTiledShapes()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00356">tilePadTensorOp()</a>.</p>

</div>
</div>
<a id="ad316c017a79db35cf486ca98aa4b9560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad316c017a79db35cf486ca98aa4b9560">&#9670;&nbsp;</a></span>computeTileSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::computeTileSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ivs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>sizeBounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute tile sizes, given a list of loop <code>ivs</code>, <code>tileSizes</code> and dimension sizes (<code>sizeBounds</code>). </p>
<p>In case a tile size is zero (i.e., no tiling), the corresponding result size is the corresponding value from <code>sizeBounds</code>. Note: The returned tile sizes are closed intervals. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00631">631</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00482">mlir::getAffineDimExpr()</a>, <a class="el" href="Builders_8h_source.html#l00053">mlir::Builder::getContext()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00074">isTiled()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00039">isZero()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00706">mlir::makeComposedAffineApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00037">applyPermutationToVector()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00646">makeTiledShapes()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00356">tilePadTensorOp()</a>.</p>

</div>
</div>
<a id="a4f8ea0aae80d24eeffa3fef8f1f08c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8ea0aae80d24eeffa3fef8f1f08c43">&#9670;&nbsp;</a></span>concat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt; mlir::linalg::concat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the vector that is the concatenation of <code>a</code> and <code>b</code>. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l02181">2181</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Simplex_8cpp_source.html#l00613">mlir::Simplex::makeProduct()</a>.</p>

</div>
</div>
<a id="ab4f0310fab99c4db7d336dd602f56d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f0310fab99c4db7d336dd602f56d1c">&#9670;&nbsp;</a></span>createOrFoldDimOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::createOrFoldDimOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function that creates a memref::DimOp or tensor::DimOp depending on the type of <code>source</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00163">163</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00413">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Value_8h_source.html#l00119">mlir::Value::getType()</a>, <a class="el" href="Types_8h_source.html#l00228">mlir::Type::isa()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l01288">loc</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00037">applyPermutationToVector()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01724">createInBoundsCond()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01332">createNewAllocDeallocPairForShapedValue()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00196">createOrFoldDimOp()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01814">createSubViewIntersection()</a>, <a class="el" href="Fusion_8cpp_source.html#l00171">fuse()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00173">getDynOperands()</a>, <a class="el" href="Loops_8cpp_source.html#l00165">getPaddedInput()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00536">makeTiledShape()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l03386">MaterializeTransferMask&lt; ConcreteOp &gt;::matchAndRewrite()</a>, and <a class="el" href="LinalgInterfaces_8cpp_source.html#l00271">HasAffineDimExprVisitor::visitSymbolExpr()</a>.</p>

</div>
</div>
<a id="af9aac538302681e906bd4261c128d90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9aac538302681e906bd4261c128d90e">&#9670;&nbsp;</a></span>defaultLoopRangesBuilder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir_1_1linalg.html#a949f3c7a426d9e0cfec01467631f8037">LoopRangeBuilder</a> mlir::linalg::defaultLoopRangesBuilder </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide a very simple inference procedure to build the loop ranges from the op and its operands. </p>
<p>This only works with permutation affine maps and patterns of the form <code>(m, n)[s] -&gt; (m + n - s floordiv 2)</code>. A more advanced Tensor-Comprehension like inference is possible but has proven to be ambiguous in unfavorable case. As a consequence, we relax the default behavior very conservatively and provide an op-specified hook so that Linalg ops may override the behavior. </p>

</div>
</div>
<a id="a61cc9e0c28375cb013346496eb9b6227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61cc9e0c28375cb013346496eb9b6227">&#9670;&nbsp;</a></span>enqueue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PatternType , typename OpType , typename OptionsType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::enqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patternList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OptionsType&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>opName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CodegenStrategy_8h_source.html#l00058">58</a> of file <a class="el" href="CodegenStrategy_8h_source.html">CodegenStrategy.h</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00917">mlir::RewritePatternSet::add()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00421">mlir::linalg::LinalgTransformationFilter::addOpFilter()</a>, <a class="el" href="PatternMatch_8h_source.html#l00893">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00083">options</a>.</p>

</div>
</div>
<a id="a6ddca37c4e3bf09cb06fc5197380bde3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ddca37c4e3bf09cb06fc5197380bde3">&#9670;&nbsp;</a></span>extractOrIdentityMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::linalg::extractOrIdentityMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>maybeMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>maybeMap.get()</code> if <code>maybeMap</code> is set, otherwise returns the symbol-less identity map of <code>rank</code>. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l02133">2133</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01042">mlir::AffineMap::get()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00259">mlir::AffineMap::getMultiDimIdentityMap()</a>.</p>

</div>
</div>
<a id="a13ad74083992ed8c5b3e804e513bdd29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ad74083992ed8c5b3e804e513bdd29">&#9670;&nbsp;</a></span>findAllFusableDependences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir_1_1linalg.html#aed2c8e52c82709202bade005c0609f77">FusableOpDependencesTy</a> mlir::linalg::findAllFusableDependences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LinalgOp &gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>dependenceGraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all dependences that are fusable. </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00746">746</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Fusion_8cpp_source.html#l00359">findFusableProducer()</a>, <a class="el" href="Operation_8h_source.html#l00096">mlir::Operation::getBlock()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l01292">op</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00899">tileAndFuseLinalgOpsImpl()</a>.</p>

</div>
</div>
<a id="aa5951d3211e4e0b1252261d70863bb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5951d3211e4e0b1252261d70863bb82">&#9670;&nbsp;</a></span>fuseProducerOfBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt; mlir::linalg::fuseProducerOfBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>consumerOpOperand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fuses producer into consumer if the producer is structurally feasible and the fusion would not violate dependencies. </p>
<p>Implements the fusion part of the "tileAndFuse on buffers" transformation and thus requires the <code>consumerOpOperand</code> to be a <code>subview</code> op (generally obtained by applying the tiling transformation). </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00417">417</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Fusion_8cpp_source.html#l00359">findFusableProducer()</a>, <a class="el" href="Fusion_8cpp_source.html#l00171">fuse()</a>, <a class="el" href="UseDefLists_8h_source.html#l00133">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="UseDefLists_8h_source.html#l00037">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="Value_8cpp_source.html#l00048">mlir::Value::getParentBlock()</a>, and <a class="el" href="Builders_8h_source.html#l00316">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="abda979eb10cc4f400eccd0fa0d594090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda979eb10cc4f400eccd0fa0d594090">&#9670;&nbsp;</a></span>fuseProducerOfTensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt; mlir::linalg::fuseProducerOfTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>consumerOpOperand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tensor counterpart of <code>fuseProducerOfBuffer</code>. </p>
<p>This implements the fusion part of the "tileAndFuse on tensors" transformation and thus requires the <code>consumerOpOperand</code> to be a <code>extract_slice</code> op (generally obtained by applying the tiling transformation). </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00487">487</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00133">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00462">getProducerOfTensor()</a>.</p>

</div>
</div>
<a id="a8e177c93e15a8494da207f0cf5c8d1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e177c93e15a8494da207f0cf5c8d1df">&#9670;&nbsp;</a></span>fuseProducerOfTensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt; mlir::linalg::fuseProducerOfTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a>&#160;</td>
          <td class="paramname"><em>producerOpResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>consumerOpOperand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tensor counterpart of <code>fuseProducerOfBuffer</code>. </p>
<p>This implements the fusion part of the "tileAndFuse on tensors" transformation and thus requires the <code>consumerOpOperand</code> to be a <code>extract_slice</code> op (generally obtained by applying the tiling transformation). Assumes <code>producerOfTensor</code> is a Linalg op that produces <code>consumerOpOperand</code>. </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00499">499</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00396">mlir::OpBuilder::create()</a>, <a class="el" href="Fusion_8cpp_source.html#l00171">fuse()</a>, <a class="el" href="UseDefLists_8h_source.html#l00133">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="UseDefLists_8h_source.html#l00037">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="Value_8h_source.html#l00434">mlir::OpResult::getOwner()</a>, <a class="el" href="Value_8cpp_source.html#l00048">mlir::Value::getParentBlock()</a>, <a class="el" href="Value_8h_source.html#l00437">mlir::OpResult::getResultNumber()</a>, <a class="el" href="Value_8h_source.html#l00119">mlir::Value::getType()</a>, <a class="el" href="UseDefLists_8h_source.html#l00136">mlir::IROperand&lt; DerivedT, IRValueT &gt;::set()</a>, and <a class="el" href="Builders_8h_source.html#l00316">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="a754ec5c5960c640563ddcd9727b77d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754ec5c5960c640563ddcd9727b77d87">&#9670;&nbsp;</a></span>generateLibraryCallName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlir::linalg::generateLibraryCallName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name mangled library call name to disambiguate between different overloads at the C level. </p>
<p>The name mangling scheme is basic and uses MLIR type names:</p><ol type="1">
<li>form a string which is the concatenation of the linalg op name with all the operand type names, separate by underscores;</li>
<li>drop the <code>linalg.</code> prefix, and the <code>&lt;</code>, <code>&gt;</code>, <code>?</code> symbols from the type. Assumes <code>op</code> is a LinalgOp.</li>
</ol>
<p>Examples:</p>
<ol type="1">
<li>linalg.fill(f, A) : f32, memref&lt;f32&gt; name mangles into <code>linalg_fill_f32_viewf32</code></li>
<li>linalg.dot A, B, C : (memref&lt;?xf32, stride_specification&gt;, memref&lt;?xf32, stride_specification&gt;, memref&lt;f32&gt;) name mangles into <code>linalg_dot_viewxf32_viewxf32_viewf32</code></li>
<li>linalg.matmul(...) : memref&lt;?x?xf32, stride_specification&gt;, memref&lt;?x?xf32, stride_specification&gt;, memref&lt;?x?xf32, stride_specification&gt; name mangles into <code>linalg_matmul_viewxxf32_viewxxf32_viewxxf32</code> </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l02210">2210</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgOps_8cpp_source.html#l02189">appendMangledType()</a>, <a class="el" href="Operation_8h_source.html#l00057">mlir::Operation::getName()</a>, <a class="el" href="Operation_8h_source.html#l00274">mlir::Operation::getOperandTypes()</a>, and <a class="el" href="Operation_8cpp_source.html#l00051">mlir::OperationName::getStringRef()</a>.</p>

</div>
</div>
<a id="a1e61b04f528d6ebbe05496f4d6ea4a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e61b04f528d6ebbe05496f4d6ea4a0e">&#9670;&nbsp;</a></span>generateParallelLoopNest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> mlir::linalg::generateParallelLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>iteratorTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;&#160;</td>
          <td class="paramname"><em>bodyBuilderFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ivStorage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982">DistributionMethod</a> &gt;&#160;</td>
          <td class="paramname"><em>distributionMethod</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a loop nest consisting of scf.parallel and scf.for, depending on the `iteratorTypes. </p>
<p>` Consecutive parallel loops create a single scf.parallel operation; each sequential loop creates a new scf.for operation. The body of the innermost loop is populated by <code>bodyBuilderFn</code> that accepts a range of induction variables for all loops. <code>ivStorage</code> is used to store the partial list of induction variables. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00358">358</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2StandardOps_2Utils_2Utils_8cpp_source.html#l00052">mlir::ArithBuilder::_and()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00476">mlir::scf::buildLoopNest()</a>, <a class="el" href="Builders_8h_source.html#l00396">mlir::OpBuilder::create()</a>, <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982ad71670d62b238eaf063979407361034e">Cyclic</a>, <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982ad93606014b9a6b479ba0e6faa948540b">CyclicNumProcsEqNumIters</a>, <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982abab54876ff518ecd2d59b46fd3be9c0e">CyclicNumProcsGeNumIters</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00119">isParallelIteratorType()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01288">loc</a>, and <a class="el" href="Dialect_2StandardOps_2Utils_2Utils_8cpp_source.html#l00070">mlir::ArithBuilder::slt()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00473">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>.</p>

</div>
</div>
<a id="a504d0107ce313528b9b8b2ecefb43e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a504d0107ce313528b9b8b2ecefb43e38">&#9670;&nbsp;</a></span>getDimsOfType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::getDimsOfType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>iteratorTypeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the dims that are <code>iteratorTypeName</code> loops in the LinalgOp <code>op</code>. </p>
<p>Assumes <code>op</code> is a LinalgOp. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l02118">2118</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00482">mlir::getAffineDimExpr()</a>, and <a class="el" href="Operation_8h_source.html#l00099">mlir::Operation::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DropUnitDims_8cpp_source.html#l00148">replaceUnitDimIndexOps()</a>.</p>

</div>
</div>
<a id="a756a0c2f5771e052c3d9f2b0dad15525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a756a0c2f5771e052c3d9f2b0dad15525">&#9670;&nbsp;</a></span>getDynOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt; mlir::linalg::getDynOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an operation, retrieves the value of each dynamic dimension through constructing the necessary DimOp operators. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00173">173</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00244">mlir::Type::cast()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00163">createOrFoldDimOp()</a>, <a class="el" href="Matchers_8h_source.html#l00196">mlir::detail::enumerate()</a>, <a class="el" href="Value_8h_source.html#l00119">mlir::Value::getType()</a>, and <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00072">mlir::ShapedType::kDynamicSize</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Bufferize_8cpp_source.html#l00036">allocateBuffersForResults()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00037">applyPermutationToVector()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Bufferize_8cpp_source.html#l00027">cloneMemref()</a>, and <a class="el" href="ElementwiseToLinalg_8cpp_source.html#l00045">getOrCreateOperandsMatchingResultTypes()</a>.</p>

</div>
</div>
<a id="ae61503376ad6b88f0c35f8ce358dbc9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61503376ad6b88f0c35f8ce358dbc9e">&#9670;&nbsp;</a></span>getLinalgTilingCanonicalizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> mlir::linalg::getLinalgTilingCanonicalizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Canonicalization patterns relevant to apply after tiling patterns. </p>
<p>These are applied automatically by the tiling pass but need to be applied manually when tiling is called programmatically. </p>

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00480">480</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="Tiling_8cpp_source.html#l00486">populateLinalgTilingCanonicalizationPatterns()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tiling_8cpp_source.html#l00519">applyExtractSliceOfPadTensorSwapPattern()</a>, <a class="el" href="Tiling_8cpp_source.html#l00529">applyTilingToLoopPatterns()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00517">mlir::linalg::LinalgTilingOptions::setPaddingValueComputationFunction()</a>, and <a class="el" href="CodegenStrategy_8cpp_source.html#l00029">mlir::linalg::CodegenStrategy::transform()</a>.</p>

</div>
</div>
<a id="a3e51b14c2f2e1baf6c168601a59f9da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e51b14c2f2e1baf6c168601a59f9da4">&#9670;&nbsp;</a></span>getSmallestBoundingIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntegerAttr mlir::linalg::getSmallestBoundingIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>size</code> comes from an AffineMinOp and one of the values of AffineMinOp is a constant then return a new value set to the smallest such constant. </p>
<p>If <code>size</code> comes from a <a class="el" href="classConstantOp.html">ConstantOp</a>, return the constant. Otherwise return nullptr.</p>
<p>Otherwise returngetSmallestBoundingIndex nullptr. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00186">186</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getContext()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l00106">min()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00037">applyPermutationToVector()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00127">padOperandToSmallestStaticBoundingBox()</a>, and <a class="el" href="Promotion_8cpp_source.html#l00212">promoteSubviewAsNewBuffer()</a>.</p>

</div>
</div>
<a id="a3a7224b24d57b2f395595d661d846257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7224b24d57b2f395595d661d846257">&#9670;&nbsp;</a></span>hoistPaddingOnTensors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::hoistPaddingOnTensors </td>
          <td>(</td>
          <td class="paramtype">PadTensorOp &amp;&#160;</td>
          <td class="paramname"><em>padTensorOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>nLoops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mechanically hoist padding operations on tensors by <code>nLoops</code> into a new, generally larger tensor. </p>
<p>This achieves packing of multiple padding ops into a larger tensor. On success, <code>padTensorOp</code> is replaced by the cloned version in the packing loop so the caller can continue reasoning about the padding operation.</p>
<h1>Example in pseudo-mlir: </h1>
<p>If hoistPaddingOnTensors is called with <code>nLoops</code> = 2 on the following IR. </p><div class="fragment"><div class="line">scf.for (%i, %<a class="code" href="unionj.html">j</a>, %k)</div><div class="line">  %st0 = <a class="code" href="namespacetensor.html">tensor</a>.extract_slice f(%i, %k) : ... to <a class="code" href="namespacetensor.html">tensor</a>&lt;?x?xf32&gt;</div><div class="line">  %0 = linalg.pad_tensor %st0 low[0, 0] high[...] {</div><div class="line">  ^bb0( ... ):</div><div class="line">    linalg.yield %pad</div><div class="line">  } : <a class="code" href="namespacetensor.html">tensor</a>&lt;?x?xf32&gt; to <a class="code" href="namespacetensor.html">tensor</a>&lt;4x8xf32&gt;</div><div class="line">  compute(%0)</div></div><!-- fragment --><p>IR resembling the following is produced:</p>
<div class="fragment"><div class="line">scf.for (%i) {</div><div class="line">  %packed_init = linalg.init_tensor range(%<a class="code" href="unionj.html">j</a>) : <a class="code" href="namespacetensor.html">tensor</a>&lt;?x4x8xf32&gt;</div><div class="line">  %packed = scf.for (%k) iter_args(%p : %packed_init) {</div><div class="line">    %st0 = <a class="code" href="namespacetensor.html">tensor</a>.extract_slice f(%i, %k) : ... to <a class="code" href="namespacetensor.html">tensor</a>&lt;?x?xf32&gt;</div><div class="line">    %0 = linalg.pad_tensor %st0 low[0, 0] high[...] {</div><div class="line">    ^bb0( ... ):</div><div class="line">      linalg.yield %pad</div><div class="line">    } : <a class="code" href="namespacetensor.html">tensor</a>&lt;?x?xf32&gt; to <a class="code" href="namespacetensor.html">tensor</a>&lt;4x8xf32&gt;</div><div class="line">    %1 = <a class="code" href="namespacetensor.html">tensor</a>.insert_slice %0 ...</div><div class="line">        : <a class="code" href="namespacetensor.html">tensor</a>&lt;4x8xf32&gt; to <a class="code" href="namespacetensor.html">tensor</a>&lt;?x4x8xf32&gt;</div><div class="line">    scf.yield %1: <a class="code" href="namespacetensor.html">tensor</a>&lt;?x4x8xf32&gt;</div><div class="line">  } -&gt; <a class="code" href="namespacetensor.html">tensor</a>&lt;?x4x8xf32&gt;</div><div class="line">  scf.for (%<a class="code" href="unionj.html">j</a>, %k) {</div><div class="line">    %st0 = <a class="code" href="namespacetensor.html">tensor</a>.extract_slice %packed [%k, 0, 0][1, 4, 8][1, 1, 1] :</div><div class="line">             tensor&lt;?x4x8xf32&gt; to tensor&lt;4x8xf32&gt;</div><div class="line">    compute(%st0)</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Hoisting_8cpp_source.html#l00806">806</a> of file <a class="el" href="Hoisting_8cpp_source.html">Hoisting.cpp</a>.</p>

<p class="reference">References <a class="el" href="Hoisting_8cpp_source.html#l00539">buildLoopIterationCount()</a>, <a class="el" href="Builders_8cpp_source.html#l00469">mlir::OpBuilder::clone()</a>, <a class="el" href="Builders_8h_source.html#l00396">mlir::OpBuilder::create()</a>, <a class="el" href="Operation_8cpp_source.html#l00479">mlir::Operation::erase()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="namespacemlir_1_1scf.html#a7e4957ac11a0c4d95f6a1494c808b392">mlir::scf::getForInductionVarOwner()</a>, <a class="el" href="Builders_8cpp_source.html#l00097">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Operation_8h_source.html#l00426">mlir::Operation::getNumRegions()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00696">hoistPaddingOnTensorsPrerequisites()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00137">mlir::ShapedType::isDynamic()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00072">mlir::ShapedType::kDynamicSize</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01288">loc</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00070">mlir::BlockAndValueMapping::lookup()</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00063">mlir::BlockAndValueMapping::lookupOrDefault()</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00030">mlir::BlockAndValueMapping::map()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01292">op</a>, <a class="el" href="Builders_8h_source.html#l00316">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="Builders_8h_source.html#l00354">mlir::OpBuilder::setInsertionPointToEnd()</a>, <a class="el" href="Builders_8h_source.html#l00349">mlir::OpBuilder::setInsertionPointToStart()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="afbc911548f9f0328faf5855ab880e7bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc911548f9f0328faf5855ab880e7bc">&#9670;&nbsp;</a></span>hoistRedundantVectorTransfers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::hoistRedundantVectorTransfers </td>
          <td>(</td>
          <td class="paramtype">FuncOp&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hoist vector.transfer_read/vector.transfer_write on buffers pairs out of immediately enclosing scf::ForOp iteratively, if the following conditions are true: </p>
<ol type="1">
<li>The two ops access the same memref with the same indices.</li>
<li>All operands are invariant under the enclosing scf::ForOp.</li>
<li>No uses of the memref either dominate the transfer_read or are dominated by the transfer_write (i.e. no aliasing between the write and the read across the loop) To improve hoisting opportunities, call the <code>moveLoopInvariantCode</code> helper function on the candidate loop above which to hoist. Hoisting the transfers results in scf::ForOp yielding the value that originally transited through memory. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Hoisting_8cpp_source.html#l00393">393</a> of file <a class="el" href="Hoisting_8cpp_source.html">Hoisting.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00051">mlir::WalkResult::advance()</a>, <a class="el" href="Dialect_2SCF_2Transforms_2Utils_8cpp_source.html#l00025">mlir::cloneWithNewYields()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00038">DBGS</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00054">mlir::getForwardSlice()</a>, <a class="el" href="Visitors_8h_source.html#l00050">mlir::WalkResult::interrupt()</a>, <a class="el" href="LoopInvariantCodeMotion_8cpp_source.html#l00078">mlir::moveLoopInvariantCode()</a>, and <a class="el" href="Dominance_8h_source.html#l00127">mlir::DominanceInfo::properlyDominates()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenStrategy_8cpp_source.html#l00029">mlir::linalg::CodegenStrategy::transform()</a>.</p>

</div>
</div>
<a id="a128bb6b2ac6de56efa82fb01ae3f258e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128bb6b2ac6de56efa82fb01ae3f258e">&#9670;&nbsp;</a></span>hoistRedundantVectorTransfersOnTensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::hoistRedundantVectorTransfersOnTensor </td>
          <td>(</td>
          <td class="paramtype">FuncOp&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same behavior as <code>hoistRedundantVectorTransfers</code> but works on tensors instead of buffers. </p>

<p class="definition">Definition at line <a class="el" href="Hoisting_8cpp_source.html#l00341">341</a> of file <a class="el" href="Hoisting_8cpp_source.html">Hoisting.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00051">mlir::WalkResult::advance()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00238">mlir::applyPatternsAndFoldGreedily()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00038">DBGS</a>, <a class="el" href="Matchers_8h_source.html#l00196">mlir::detail::enumerate()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00099">findMatchingTransferRead()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00223">getLoopInvariantTransferWriteOpDefining()</a>, <a class="el" href="Operation_8h_source.html#l00267">mlir::Operation::getOpOperand()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00261">hoistReadWrite()</a>, <a class="el" href="Visitors_8h_source.html#l00050">mlir::WalkResult::interrupt()</a>, and <a class="el" href="Hoisting_8cpp_source.html#l00162">tensorChunkAccessedByUnknownOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenStrategy_8cpp_source.html#l00029">mlir::linalg::CodegenStrategy::transform()</a>.</p>

</div>
</div>
<a id="a770981e996593487fafc3a47ac9c4be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770981e996593487fafc3a47ac9c4be9">&#9670;&nbsp;</a></span>insertVectorizationPatternImpl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpType , typename  = std::enable_if_t&lt;detect_has_get_operation_name&lt;OpType&gt;::value&gt;, typename  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::insertVectorizationPatternImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patternList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgVectorizationOptions.html">linalg::LinalgVectorizationOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SFINAE helper for single C++ op with a <code>getOperationName</code> method. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00764">764</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00917">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00893">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00083">options</a>.</p>

</div>
</div>
<a id="a7b512a9592500c7fb570fea733d3591f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b512a9592500c7fb570fea733d3591f">&#9670;&nbsp;</a></span>insertVectorizationPatternImpl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpType , typename  = std::enable_if_t&lt;                               !detect_has_get_operation_name&lt;OpType&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::insertVectorizationPatternImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patternList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgVectorizationOptions.html">linalg::LinalgVectorizationOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SFINAE helper for single C++ class without a <code>getOperationName</code> method (e.g. </p>
<p>an <a class="el" href="classmlir_1_1OpInterface.html" title="This class represents the base of an operation interface. ">OpInterface</a>). </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00775">775</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00917">mlir::RewritePatternSet::add()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00421">mlir::linalg::LinalgTransformationFilter::addOpFilter()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00893">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ab6d3a5c3a62ba42651c654bac998b69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d3a5c3a62ba42651c654bac998b69e">&#9670;&nbsp;</a></span>insertVectorizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... OpTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::insertVectorizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patternList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgVectorizationOptions.html">linalg::LinalgVectorizationOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>&#160;</td>
          <td class="paramname"><em>f</em> = <code><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variadic helper function to insert vectorization patterns for C++ ops. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00784">784</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00083">options</a>.</p>

</div>
</div>
<a id="a4223ee2d6488e478b0a9e86897094a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4223ee2d6488e478b0a9e86897094a9a">&#9670;&nbsp;</a></span>interchangeGenericOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::interchangeGenericOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GenericOp&#160;</td>
          <td class="paramname"><em>genericOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td>
          <td class="paramname"><em>interchangeVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interchanges the <code>iterator_types</code> and <code>iterator_maps</code> dimensions and adapts the index accesses of <code>op</code>. </p>
<p>This is an in-place transformation controlled by <code>interchangeVector</code>. An empty vector is interpreted as the identity permutation and the transformation returns early.</p>
<p>E.g. the permutation <code>(i,j,k) -&gt; (j,k,i)</code> is expressed with <code>interchangeVector = [1,2,0]</code>. All values in <code>interchangeVector</code> must be integers, in the range 0..<code>op.rank</code> without duplications (i.e. <code>[1,1,2]</code> is an invalid permutation). </p>

<p class="definition">Definition at line <a class="el" href="Interchange_8cpp_source.html#l00046">46</a> of file <a class="el" href="Interchange_8cpp_source.html">Interchange.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00037">applyPermutationToVector()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00451">mlir::AffineMap::compose()</a>, <a class="el" href="Builders_8h_source.html#l00396">mlir::OpBuilder::create()</a>, <a class="el" href="Block_8h_source.html#l00145">mlir::Block::front()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00047">mlir::getIndexingMapsAttrName()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00051">mlir::getIteratorTypesAttrName()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00205">mlir::AffineMap::getPermutationMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00512">mlir::AffineMap::getSubMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00666">mlir::inversePermutation()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00282">mlir::AffineMap::isEmpty()</a>, <a class="el" href="PatternMatch_8h_source.html#l00731">mlir::RewriterBase::replaceOpWithNewOp()</a>, and <a class="el" href="Builders_8h_source.html#l00316">mlir::OpBuilder::setInsertionPoint()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00396">mlir::linalg::GenericOpInterchangePattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a9af1c8a390189f7f1882bfd1181f8112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af1c8a390189f7f1882bfd1181f8112">&#9670;&nbsp;</a></span>interchangeGenericOpPrecondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::interchangeGenericOpPrecondition </td>
          <td>(</td>
          <td class="paramtype">GenericOp&#160;</td>
          <td class="paramname"><em>genericOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td>
          <td class="paramname"><em>interchangeVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emits a <code>generic</code> operation with the <code>indexing_maps</code> and <code>iterator_types</code> permutated according to <code>permutation</code>. </p>

<p class="definition">Definition at line <a class="el" href="Interchange_8cpp_source.html#l00033">33</a> of file <a class="el" href="Interchange_8cpp_source.html">Interchange.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00205">mlir::AffineMap::getPermutationMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00666">mlir::inversePermutation()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00396">mlir::linalg::GenericOpInterchangePattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="ab5277093c168682f123f1e99d90461f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5277093c168682f123f1e99d90461f0">&#9670;&nbsp;</a></span>isaContractionOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isaContractionOpInterface </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether <code>linalgOp</code> conforms to ContractionOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00119">119</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgInterfaces_8cpp_source.html#l00100">isContractionInterfaceImpl()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01292">op</a>, and <a class="el" href="LinalgInterfaces_8cpp_source.html#l00093">Success</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l00555">vectorizeContraction()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00647">vectorizeLinalgOp()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00628">vectorizeLinalgOpPrecondition()</a>.</p>

</div>
</div>
<a id="a6bf6605778cf3f93537f2bc2e58da089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf6605778cf3f93537f2bc2e58da089">&#9670;&nbsp;</a></span>isFusableInto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isFusableInto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>consumedView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>producer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether fusing the specific <code>producer</code> of the <code>consumedView</code> is feasible. </p>
<p>This checks <code>producer</code> is the last write of <code>consumedView</code> and that no interleaved dependence would be violated (RAW, WAR or WAW). </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00325">325</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DependenceAnalysis_8cpp_source.html#l00214">mlir::linalg::LinalgDependenceGraph::findCoveringDependences()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00301">isProducerLastWriteOfView()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00037">applyPermutationToVector()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00359">findFusableProducer()</a>.</p>

</div>
</div>
<a id="a9742d07020a6835f7a1855ef4f81c294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9742d07020a6835f7a1855ef4f81c294">&#9670;&nbsp;</a></span>isParallelIteratorType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isParallelIteratorType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an iterator_type attribute is parallel. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00119">119</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00111">mlir::Attribute::dyn_cast()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00077">mlir::getParallelIteratorTypeName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00037">applyPermutationToVector()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00220">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00358">generateParallelLoopNest()</a>.</p>

</div>
</div>
<a id="a1a2959f54ccc7cabc35c9337f50c0734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2959f54ccc7cabc35c9337f50c0734">&#9670;&nbsp;</a></span>isProducerLastWriteOfView()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isProducerLastWriteOfView </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>consumedView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>producer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the specific <code>producer</code> is the last write to exactly the whole <code>consumedView</code>. </p>
<p>This checks structural dominance, that the dependence is a RAW without any interleaved write to any piece of <code>consumedView</code>. </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00301">301</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DependenceAnalysis_8cpp_source.html#l00221">mlir::linalg::LinalgDependenceGraph::findCoveringWrites()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00280">isStructurallyFusableProducer()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00037">applyPermutationToVector()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00325">isFusableInto()</a>.</p>

</div>
</div>
<a id="af7bde6d8fa6533d77b1d706654f0f963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7bde6d8fa6533d77b1d706654f0f963">&#9670;&nbsp;</a></span>isReductionIteratorType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isReductionIteratorType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an iterator_type attribute is parallel. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00126">126</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00111">mlir::Attribute::dyn_cast()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00084">mlir::getReductionIteratorTypeName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00037">applyPermutationToVector()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00765">genFor()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00191">reduceIfNeeded()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00617">reductionPreconditions()</a>.</p>

</div>
</div>
<a id="ad0ecab0d508abda7349407fa91a3b47e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ecab0d508abda7349407fa91a3b47e">&#9670;&nbsp;</a></span>isWindowIteratorType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isWindowIteratorType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an iterator_type attribute is parallel. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00133">133</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00111">mlir::Attribute::dyn_cast()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00091">mlir::getWindowIteratorTypeName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00037">applyPermutationToVector()</a>.</p>

</div>
</div>
<a id="aecfc5511c5ab572fb035439d107da67d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecfc5511c5ab572fb035439d107da67d">&#9670;&nbsp;</a></span>linalgOpToAffineLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt; mlir::linalg::linalgOpToAffineLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emits a loop nest of <code>affine.for</code> with the proper body for <code>linalgOp</code>. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00630">630</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorTransforms_8cpp_source.html#l01287">rewriter</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00817">mlir::linalg::LinalgLoweringPattern&lt; OpTy &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a742f1b413a8aa1536e1e281946ee0984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742f1b413a8aa1536e1e281946ee0984">&#9670;&nbsp;</a></span>linalgOpToLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt; mlir::linalg::linalgOpToLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emits a loop nest of <code>scf.for</code> with the proper body for <code>linalgOp</code>. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00636">636</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorTransforms_8cpp_source.html#l01287">rewriter</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00817">mlir::linalg::LinalgLoweringPattern&lt; OpTy &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a217fdb304b3bca1db824e4a3a2903732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a217fdb304b3bca1db824e4a3a2903732">&#9670;&nbsp;</a></span>linalgOpToParallelLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt; mlir::linalg::linalgOpToParallelLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emits a loop nest of <code>scf.parallel</code> with the proper body for <code>linalgOp</code>. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00643">643</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorTransforms_8cpp_source.html#l01287">rewriter</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00817">mlir::linalg::LinalgLoweringPattern&lt; OpTy &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a962a46fba2ac497e30bb6d23fef35d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962a46fba2ac497e30bb6d23fef35d1a">&#9670;&nbsp;</a></span>makeAffineDimExprs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt; mlir::linalg::makeAffineDimExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;&#160;</td>
          <td class="paramname"><em>startIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>num</code> <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression. ">AffineDimExpr</a> dimensions at positions [startIdx, startIdx + num) and increments <code>startIdx</code> to <code>startIdx + num</code>. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l02144">2144</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00482">mlir::getAffineDimExpr()</a>.</p>

</div>
</div>
<a id="ac5a2c33620e8df50304c417a9bdee36e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a2c33620e8df50304c417a9bdee36e">&#9670;&nbsp;</a></span>makeTiledShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::makeTiledShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>valueToTile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>subShapeSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an extract_slice/subview op for a single <code>valueToTile</code> with <code>builder</code>. </p>
<p>This new operation extracts a tile of <code>valueToTile</code>, starting at offsets <code>lbs</code> and with sizes <code>subShapeSizes</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00536">536</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgInterfaces_8cpp_source.html#l00178">applyMapToValues()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00322">mlir::bindDims()</a>, <a class="el" href="Builders_8h_source.html#l00396">mlir::OpBuilder::create()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00163">createOrFoldDimOp()</a>, <a class="el" href="Types_8h_source.html#l00238">mlir::Type::dyn_cast()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00697">mlir::fullyComposeAffineMapAndOperands()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00492">mlir::getAffineSymbolExpr()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00052">mlir::getAsOpFoldResult()</a>, <a class="el" href="Builders_8h_source.html#l00053">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00097">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00052">mlir::Builder::getIndexType()</a>, <a class="el" href="Operation_8h_source.html#l00284">mlir::Operation::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00512">mlir::AffineMap::getSubMap()</a>, <a class="el" href="Value_8h_source.html#l00119">mlir::Value::getType()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00250">mlir::AffineMap::inferFromExprList()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00137">mlir::ShapedType::isDynamic()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00074">isTiled()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01288">loc</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00706">mlir::makeComposedAffineApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00037">applyPermutationToVector()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00646">makeTiledShapes()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00356">tilePadTensorOp()</a>.</p>

</div>
</div>
<a id="a77f6409a20cf9ca1db0996f6f3dd4f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f6409a20cf9ca1db0996f6f3dd4f53">&#9670;&nbsp;</a></span>makeTiledShapes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt; mlir::linalg::makeTiledShapes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>valuesToTile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ivs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>sizeBounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates extract_slice/subview ops for all <code>valuesToTile</code> of the given <code>linalgOp</code> with <code>builder</code>, assuming <code>linalgOp</code> is being fused into a loop nest for tiling with the given induction variables <code>ivs</code> and tile sizes <code>tileSizes</code>. </p>
<p><code>sizeBounds</code> are the iteration space bounds for <em>all</em> the implicit loops in <code>linalgOp</code>.</p>
<p>Note that a constant zero in <code>tileSizes</code> means no tiling at that implicit loop. The number of non-zero values in <code>tileSizes</code> should be equal to the number of values in <code>ivs</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00646">646</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00617">computeTileOffsets()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00631">computeTileSizes()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00074">isTiled()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00039">isZero()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00536">makeTiledShape()</a>, and <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00174">map()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00037">applyPermutationToVector()</a>, <a class="el" href="Fusion_8cpp_source.html#l00171">fuse()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00169">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="a09260a76a605cbb154f1a4d802feeea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09260a76a605cbb154f1a4d802feeea9">&#9670;&nbsp;</a></span>populateConvVectorizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateConvVectorizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates patterns for vectorization of all ConvN-D ops. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01162">1162</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<a id="a46f808101854ba4429cc752879269e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46f808101854ba4429cc752879269e28">&#9670;&nbsp;</a></span>populateElementwiseOpsFusionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateElementwiseOpsFusionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgElementwiseFusionOptions.html">LinalgElementwiseFusionOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structmlir_1_1linalg_1_1LinalgElementwiseFusionOptions.html">LinalgElementwiseFusionOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns for fusing linalg operation on tensors. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01392">1392</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00917">mlir::RewritePatternSet::add()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00109">mlir::linalg::LinalgElementwiseFusionOptions::controlElementwiseOpsFusionFn</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00097">mlir::linalg::LinalgElementwiseFusionOptions::controlFoldingReshapesFn</a>, <a class="el" href="PatternMatch_8h_source.html#l00893">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01384">populateFoldReshapeOpsByExpansionPatterns()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00115">mlir::linalg::LinalgElementwiseFusionOptions::setControlElementwiseOpsFusionFn()</a>, and <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01243">skipUnitDimReshape()</a>.</p>

</div>
</div>
<a id="a7a49133ef595966377878adc42196f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a49133ef595966377878adc42196f47">&#9670;&nbsp;</a></span>populateElementwiseToLinalgConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateElementwiseToLinalgConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns that convert <code>ElementwiseMappable</code> ops to linalg parallel loops. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseToLinalg_8cpp_source.html#l00119">119</a> of file <a class="el" href="ElementwiseToLinalg_8cpp_source.html">ElementwiseToLinalg.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00917">mlir::RewritePatternSet::add()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02804">mlir::applyPartialConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="PatternMatch_8h_source.html#l00893">mlir::RewritePatternSet::getContext()</a>, <a class="el" href="ElementwiseToLinalg_8cpp_source.html#l00021">isElementwiseMappableOpOnRankedTensors()</a>, <a class="el" href="DialectConversion_8h_source.html#l00752">mlir::ConversionTarget::markUnknownOpDynamicallyLegal()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l01292">op</a>.</p>

</div>
</div>
<a id="a5b6b7bc78a3dd3530d45e50a15e48af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6b7bc78a3dd3530d45e50a15e48af5">&#9670;&nbsp;</a></span>populateFoldReshapeOpsByExpansionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateFoldReshapeOpsByExpansionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1linalg.html#a7f0c7d5683991009cfddd7748b7f8d4d">ControlElementwiseOpsFusionFn</a>&#160;</td>
          <td class="paramname"><em>controlFoldingReshapes</em> = <code><a class="el" href="namespacemlir_1_1linalg.html#ae949a412565c20b3d334a8d3a26acab3">skipUnitDimReshape</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to fold an expanding (collapsing) tensor_reshape operation with its producer (consumer) generic operation by expanding the dimensionality of the loop in the generic op. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01384">1384</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00917">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00893">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01392">populateElementwiseOpsFusionPatterns()</a>.</p>

</div>
</div>
<a id="a83456e96c4abd883654638b15422f2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83456e96c4abd883654638b15422f2f7">&#9670;&nbsp;</a></span>populateFoldReshapeOpsByLinearizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateFoldReshapeOpsByLinearizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to fold a collapsing (expanding) tensor_reshape operation with its producer (consumer) generic operation by linearizing the indexing map used to access the source (target) of the reshape operation in the generic operation. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01364">1364</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00917">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00893">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01243">skipUnitDimReshape()</a>.</p>

</div>
</div>
<a id="aaab9722666a91e7e3d5e93b24bb9f8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab9722666a91e7e3d5e93b24bb9f8f2">&#9670;&nbsp;</a></span>populateFoldUnitDimsReshapeOpsByLinearizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateFoldUnitDimsReshapeOpsByLinearizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to fold a collapsing (expanding) tensor_reshape operation with its producer (consumer) generic operation by linearizing the indexing map used to access the source (target) of the reshape operation in the generic operation. </p>
<p>The patterns are applied only when the tensor reshape involved is collapsing (introducing) unit-extent dimensions. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01374">1374</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00917">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00893">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01243">skipUnitDimReshape()</a>.</p>

</div>
</div>
<a id="a1578d606ad73b93f532062fef0ce6574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1578d606ad73b93f532062fef0ce6574">&#9670;&nbsp;</a></span>populateFoldUnitExtentDimsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateFoldUnitExtentDimsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to fold unit-extent dimensions in operands/results of linalg ops on tensors. </p>
<p>Patterns that are used to canonicalize the use of unit-extent dims for broadcasting.</p>

<p class="definition">Definition at line <a class="el" href="DropUnitDims_8cpp_source.html#l00547">547</a> of file <a class="el" href="DropUnitDims_8cpp_source.html">DropUnitDims.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00917">mlir::RewritePatternSet::add()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00238">mlir::applyPatternsAndFoldGreedily()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00893">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="acc64a8c8a9ecf3de84383893d8e4ddc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc64a8c8a9ecf3de84383893d8e4ddc2">&#9670;&nbsp;</a></span>populateInlineConstantOperandsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateInlineConstantOperandsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns that are used to inline constant operands into linalg generic ops. </p>

<p class="definition">Definition at line <a class="el" href="InlineScalarOperands_8cpp_source.html#l00088">88</a> of file <a class="el" href="InlineScalarOperands_8cpp_source.html">InlineScalarOperands.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00917">mlir::RewritePatternSet::add()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00238">mlir::applyPatternsAndFoldGreedily()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00893">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="aa5a371b7b0b87abfdcef373c3ac312a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a371b7b0b87abfdcef373c3ac312a8">&#9670;&nbsp;</a></span>populateLinalgBufferizePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateLinalgBufferizePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1BufferizeTypeConverter.html">BufferizeTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the given list with patterns to bufferize linalg ops. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Bufferize_8cpp_source.html#l00351">351</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00917">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00893">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Bufferize_8cpp_source.html#l00116">finalizeBufferAllocation()</a>.</p>

</div>
</div>
<a id="aff0ad2d062832055fdca9b113bb54285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0ad2d062832055fdca9b113bb54285">&#9670;&nbsp;</a></span>populateLinalgConvGeneralizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateLinalgConvGeneralizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">LinalgTransformationFilter</a>&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">LinalgTransformationFilter</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <code>patterns</code> with patterns to convert linalg.conv ops to linalg.generic ops. </p>

<p class="definition">Definition at line <a class="el" href="Generalization_8cpp_source.html#l00183">183</a> of file <a class="el" href="Generalization_8cpp_source.html">Generalization.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00917">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00893">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Generalization_8cpp_source.html#l00034">createGenericOpFromNamedOp()</a>, and <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00817">mlir::linalg::LinalgLoweringPattern&lt; OpTy &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a7bc8eeefb74502116e8a8a57d48369a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bc8eeefb74502116e8a8a57d48369a5">&#9670;&nbsp;</a></span>populateLinalgDistributeTiledLoopPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateLinalgDistributeTiledLoopPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgLoopDistributionOptions.html">LinalgLoopDistributionOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">LinalgTransformationFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>marker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linalg distribution patterns. </p>
<p>Populates <code>patterns</code> with patterns to distribute linalg.tiled_loop. </p>

<p class="definition">Definition at line <a class="el" href="Distribution_8cpp_source.html#l00081">81</a> of file <a class="el" href="Distribution_8cpp_source.html">Distribution.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00917">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00893">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00817">mlir::linalg::LinalgLoweringPattern&lt; OpTy &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a60cd962332e381639e396c646c82eb14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60cd962332e381639e396c646c82eb14">&#9670;&nbsp;</a></span>populateLinalgNamedOpsGeneralizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateLinalgNamedOpsGeneralizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">LinalgTransformationFilter</a>&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">LinalgTransformationFilter</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linalg generalization patterns. </p>
<p>Populates <code>patterns</code> with patterns to convert spec-generated named ops to linalg.generic ops. </p>

<p class="definition">Definition at line <a class="el" href="Generalization_8cpp_source.html#l00188">188</a> of file <a class="el" href="Generalization_8cpp_source.html">Generalization.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00917">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00893">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Generalization_8cpp_source.html#l00034">createGenericOpFromNamedOp()</a>, and <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00817">mlir::linalg::LinalgLoweringPattern&lt; OpTy &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a4701ad0fa2e34da0089a80135935f02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4701ad0fa2e34da0089a80135935f02e">&#9670;&nbsp;</a></span>populateLinalgTilingCanonicalizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateLinalgTilingCanonicalizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00486">486</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00893">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tiling_8cpp_source.html#l00480">getLinalgTilingCanonicalizationPatterns()</a>, and <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00517">mlir::linalg::LinalgTilingOptions::setPaddingValueComputationFunction()</a>.</p>

</div>
</div>
<a id="a703d4f21c6f57b8c680dc20dd6928a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703d4f21c6f57b8c680dc20dd6928a61">&#9670;&nbsp;</a></span>populateLinalgToStandardConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateLinalgToStandardConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from Linalg to Standard. </p>

<p class="definition">Definition at line <a class="el" href="LinalgToStandard_8cpp_source.html#l00165">165</a> of file <a class="el" href="LinalgToStandard_8cpp_source.html">LinalgToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00917">mlir::RewritePatternSet::add()</a>, <a class="el" href="DialectConversion_8h_source.html#l00723">mlir::ConversionTarget::addLegalDialect()</a>, <a class="el" href="DialectConversion_8h_source.html#l00640">mlir::ConversionTarget::addLegalOp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02824">mlir::applyFullConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00893">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a1d99ec53d8d90c200b932f59c1633742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d99ec53d8d90c200b932f59c1633742">&#9670;&nbsp;</a></span>populatePadTensorOpVectorizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populatePadTensorOpVectorizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>baseBenefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <code>patterns</code> with patterns that vectorize linalg.pad_tensor. </p>
<p>These patterns are meant to apply in a complementary fashion. Benefits are used to encode a certain ordering of pattern application. To avoid scattering magic constants throughout the code base, the patterns must be added with this function. <code>baseBenefit</code> can be used to offset the benefit of all PadTensorOp vectorization patterns by a certain value. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01052">1052</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00917">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00023">mlir::PatternBenefit::getBenefit()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00893">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ae8660b99b3f1cd3f42085e6c6694b0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8660b99b3f1cd3f42085e6c6694b0a0">&#9670;&nbsp;</a></span>populatePushReshapeOpsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populatePushReshapeOpsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to push reshape op towards the end of the graph in order to expose more fusion opportunities. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01408">1408</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00917">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00893">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00115">mlir::linalg::LinalgElementwiseFusionOptions::setControlElementwiseOpsFusionFn()</a>.</p>

</div>
</div>
<a id="a141726cc3e876dde26944874a419e36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141726cc3e876dde26944874a419e36c">&#9670;&nbsp;</a></span>populateTiledLoopToSCFPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateTiledLoopToSCFPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to convert TiledLoopOp to SCF loops. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00605">605</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00917">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00893">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Loops_8cpp_source.html#l00412">linalgOpToLoopsImpl()</a>.</p>

</div>
</div>
<a id="aa56a19420366b42fc7ead95445775b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa56a19420366b42fc7ead95445775b3a">&#9670;&nbsp;</a></span>promoteSubviewAsNewBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1PromotionInfo.html">PromotionInfo</a> &gt; mlir::linalg::promoteSubviewAsNewBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::SubViewOp&#160;</td>
          <td class="paramname"><em>subView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1linalg.html#a15f98a29e8d8529d00b3b406f009767e">AllocBufferCallbackFn</a>&#160;</td>
          <td class="paramname"><em>allocationFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00212">212</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00396">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8h_source.html#l00413">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Matchers_8h_source.html#l00196">mlir::detail::enumerate()</a>, <a class="el" href="Builders_8cpp_source.html#l00097">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00186">getSmallestBoundingIndex()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l01288">loc</a>.</p>

<p class="reference">Referenced by <a class="el" href="Promotion_8cpp_source.html#l00247">promoteSubViews()</a>.</p>

</div>
</div>
<a id="aecc074a275eb7463fb59cf548d25f6d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc074a275eb7463fb59cf548d25f6d4">&#9670;&nbsp;</a></span>promoteSubViews()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; LinalgOp &gt; mlir::linalg::promoteSubViews </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes the <code>subViews</code> into a new buffer allocated at the insertion point <code>b</code>. </p>
<p>Promotion occurs in 3 steps:</p><ol type="1">
<li>Create a new buffer for a full tile (i.e. not clipped at the boundary).</li>
<li>Take a full view on the buffer.</li>
<li>Take a partial slice of the full view in step 2. and copy into it. Infers statically sized buffers from subViews unless <code>dynamicBuffers</code> is true.</li>
</ol>
<p>Returns the modified linalg op (the modification happens in place) as well as all the copy ops created. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00383">383</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00286">mlir::DataLayout::closest()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01292">op</a>, <a class="el" href="Promotion_8cpp_source.html#l00247">promoteSubViews()</a>, <a class="el" href="Promotion_8cpp_source.html#l00361">promoteSubviewsPrecondition()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00283">mlir::linalg::LinalgPromotionOptions::setDynamicBuffers()</a>, and <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00295">mlir::linalg::LinalgPromotionOptions::setUseAlloca()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00419">mlir::linalg::LinalgBasePromotionPattern::matchAndRewrite()</a>, and <a class="el" href="Promotion_8cpp_source.html#l00303">promoteSubViews()</a>.</p>

</div>
</div>
<a id="a850b9fd11404efe17bca02011aff2e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850b9fd11404efe17bca02011aff2e88">&#9670;&nbsp;</a></span>promoteSubviewsPrecondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::promoteSubviewsPrecondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structmlir_1_1linalg_1_1Promote.html" title="Promotion transformation enqueues a particular stage-1 pattern for Promote&lt;LinalgOpType&gt;with the appr...">Promote</a> std.subviews feeding linalg operations. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00361">361</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01292">op</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00253">mlir::linalg::LinalgPromotionOptions::operandsToPromote</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00419">mlir::linalg::LinalgBasePromotionPattern::matchAndRewrite()</a>, and <a class="el" href="Promotion_8cpp_source.html#l00383">promoteSubViews()</a>.</p>

</div>
</div>
<a id="ae15aaf2258ce2e092c635d257d0bc276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae15aaf2258ce2e092c635d257d0bc276">&#9670;&nbsp;</a></span>sfinae_enqueue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; class PatternType, typename ConcreteOpType , typename OptionsType , typename  = std::enable_if_t&lt;std::is_member_function_pointer&lt;              decltype(&amp;ConcreteOpType::getOperationName)&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::sfinae_enqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patternList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OptionsType&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>opName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SFINAE: Enqueue helper for ConcreteOpType that have a <code>getOperationName</code>. </p>

<p class="definition">Definition at line <a class="el" href="CodegenStrategy_8h_source.html#l00038">38</a> of file <a class="el" href="CodegenStrategy_8h_source.html">CodegenStrategy.h</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00917">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00893">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00083">options</a>.</p>

</div>
</div>
<a id="a46a3ec018fb2c3f8170acbd560b0044c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a3ec018fb2c3f8170acbd560b0044c">&#9670;&nbsp;</a></span>sfinae_enqueue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; class PatternType, typename OpType , typename OptionsType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::sfinae_enqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patternList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OptionsType&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>opName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SFINAE: Enqueue helper for OpType that do not have a <code>getOperationName</code> (e.g. </p>
<p>LinalgOp, other interfaces, Operation*). </p>

<p class="definition">Definition at line <a class="el" href="CodegenStrategy_8h_source.html#l00050">50</a> of file <a class="el" href="CodegenStrategy_8h_source.html">CodegenStrategy.h</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00917">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00893">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00083">options</a>.</p>

</div>
</div>
<a id="ae949a412565c20b3d334a8d3a26acab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae949a412565c20b3d334a8d3a26acab3">&#9670;&nbsp;</a></span>skipUnitDimReshape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::skipUnitDimReshape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1OpResult.html">OpResult</a> &amp;&#160;</td>
          <td class="paramname"><em>producer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>consumer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default function to control reshape folding. </p>
<p>Skips folding unit dimension reshapes. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01243">1243</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00238">mlir::applyPatternsAndFoldGreedily()</a>, <a class="el" href="PatternMatch_8h_source.html#l00773">mlir::RewriterBase::cancelRootUpdate()</a>, <a class="el" href="Builders_8h_source.html#l00396">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8h_source.html#l00413">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Types_8h_source.html#l00238">mlir::Type::dyn_cast()</a>, <a class="el" href="Matchers_8h_source.html#l00196">mlir::detail::enumerate()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="PatternMatch_8h_source.html#l00769">mlir::RewriterBase::finalizeRootUpdate()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01233">fuseElementwiseOps()</a>, <a class="el" href="Operation_8h_source.html#l00099">mlir::Operation::getContext()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Operation_8h_source.html#l00429">mlir::Operation::getRegions()</a>, <a class="el" href="Value_8h_source.html#l00119">mlir::Value::getType()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00379">isUnitDimExpansionOnly()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00072">mlir::ShapedType::kDynamicSize</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01288">loc</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01292">op</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01392">populateElementwiseOpsFusionPatterns()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01364">populateFoldReshapeOpsByLinearizationPatterns()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01374">populateFoldUnitDimsReshapeOpsByLinearizationPatterns()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00221">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00764">mlir::RewriterBase::startRootUpdate()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="af2ed960597938202b576c1a3e01e07ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ed960597938202b576c1a3e01e07ed">&#9670;&nbsp;</a></span>substituteMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1linalg_1_1AffineMapAndOperands.html">AffineMapAndOperands</a> mlir::linalg::substituteMin </td>
          <td>(</td>
          <td class="paramtype">AffineMinOp&#160;</td>
          <td class="paramname"><em>affineMinOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1linalg.html#a26f1b76eab74d8bc4ba354b1c6e67a6b">GetMinMaxExprFn</a>&#160;</td>
          <td class="paramname"><em>getMinMaxExpr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse the dims of the <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> of <code>affineMinOp</code> and substitute dimensions with known range by new expressions involving the min or max expression: </p>
<ul>
<li>If the <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression. ">AffineDimExpr</a> mapped to a known value has a positive sign, it is replaced by the min expression.</li>
<li>If the <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression. ">AffineDimExpr</a> mapped to a known value has a negative sign, it is replaced by the max expression. All known values are iteratively replaced. This is used as an intermediate step in computing bounding boxes and canonicalize AffineMinOps. All dim and symbol operands are assumed to have positive values (positive orthant assumptions). Return a new <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a>, dims and symbols that have been canonicalized and simplified. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00574">574</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00501">substitute()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00584">mlir::linalg::AffineMinRangeCanonicalizationPattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a0d0dffca46cdba77603c5b6b113d5c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0dffca46cdba77603c5b6b113d5c7a">&#9670;&nbsp;</a></span>tileAndFuseLinalgOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1TiledAndFusedLinalgOps.html">TiledAndFusedLinalgOps</a> &gt; mlir::linalg::tileAndFuseLinalgOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LinalgOp &gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>dependenceGraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>tilingOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00967">967</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325a4b2257cb98694284507e77f34e73c2d8">Loops</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00485">mlir::linalg::LinalgTilingOptions::loopType</a>, <a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325ab92546344b4e3fa9b10c9472795297a7">ParallelLoops</a>, <a class="el" href="Fusion_8cpp_source.html#l00899">tileAndFuseLinalgOpsImpl()</a>, and <a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325a695eb12d246fdee4efda9a552f92406e">TiledLoops</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00303">mlir::linalg::LinalgBaseTileAndFusePattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="ab2efdb9223f206f2d1f8f8ee6b27564f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2efdb9223f206f2d1f8f8ee6b27564f">&#9670;&nbsp;</a></span>tileLinalgOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">TiledLinalgOp</a> &gt; mlir::linalg::tileLinalgOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00339">339</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325a4b2257cb98694284507e77f34e73c2d8">Loops</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00485">mlir::linalg::LinalgTilingOptions::loopType</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01292">op</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00083">options</a>, <a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325ab92546344b4e3fa9b10c9472795297a7">ParallelLoops</a>, and <a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325a695eb12d246fdee4efda9a552f92406e">TiledLoops</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00303">mlir::linalg::LinalgBaseTileAndFusePattern::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00239">mlir::linalg::LinalgBaseTilingPattern::matchAndRewriteBase()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00804">tileRootOperation()</a>.</p>

</div>
</div>
<a id="aeb173d5edf56a08ed3610924312dd364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb173d5edf56a08ed3610924312dd364">&#9670;&nbsp;</a></span>updateBoundsForCyclicDistribution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::updateBoundsForCyclicDistribution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>procId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>nprocs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the <code>lb</code>, <code>ub</code> and <code>step</code> to get per processor <code>lb</code>, <code>ub</code> and <code>step</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00338">338</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8h_source.html#l00322">mlir::bindDims()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00492">mlir::getAffineSymbolExpr()</a>, <a class="el" href="Builders_8h_source.html#l00053">mlir::Builder::getContext()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00706">mlir::makeComposedAffineApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00473">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>.</p>

</div>
</div>
<a id="aafecf344e928b95496d372d78ae592a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafecf344e928b95496d372d78ae592a0">&#9670;&nbsp;</a></span>vectorizeLinalgOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::vectorizeLinalgOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>newResults</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a suitable vector form for a Linalg op with fully static shape. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00647">647</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Vectorization_8cpp_source.html#l00040">DEBUG_TYPE</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00119">isaContractionOpInterface()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01292">op</a>, <a class="el" href="Vectorization_8cpp_source.html#l00459">vectorizeAsLinalgGeneric()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00555">vectorizeContraction()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00628">vectorizeLinalgOpPrecondition()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00451">mlir::linalg::LinalgBaseVectorizationPattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a434bd78a651f6a42d01090db72bc039c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434bd78a651f6a42d01090db72bc039c">&#9670;&nbsp;</a></span>vectorizeLinalgOpPrecondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::vectorizeLinalgOpPrecondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite a linalg.generic into a suitable vector.contraction op. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00628">628</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Vectorization_8cpp_source.html#l00610">allIndexingsAreProjectedPermutation()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00119">isaContractionOpInterface()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00421">isElementwise()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01292">op</a>, <a class="el" href="Vectorization_8cpp_source.html#l00617">reductionPreconditions()</a>, <a class="el" href="LogicalResult_8h_source.html#l00068">mlir::succeeded()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l00647">vectorizeLinalgOp()</a>.</p>

</div>
</div>
<a id="ab5dd029acdda95eeb6887d0e169bcbb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5dd029acdda95eeb6887d0e169bcbb5">&#9670;&nbsp;</a></span>weightedPoolingInputIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PoolingOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt; mlir::linalg::weightedPoolingInputIndex </td>
          <td>(</td>
          <td class="paramtype">PoolingOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>outputDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>windowDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds the indexing expressions for a ConvOp/PoolingOp <code>op</code>. </p>
<p>Returns the vector of AffineMaps representing: <code>stride[i] * outputDims[i] + dilation[i] * windowDims[i] - pad_low[i]</code> </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l02155">2155</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jul 26 2021 04:33:17 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
